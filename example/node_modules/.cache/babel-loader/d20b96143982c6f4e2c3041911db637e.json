{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _parseUrl = require(\"./parse-url\");\n\nfunction matchHas(req, has, query) {\n  var params = {};\n  var allMatch = has.every(function (hasItem) {\n    var value;\n    var key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          var _ref = (req == null ? void 0 : req.headers) || {},\n              host = _ref.host; // remove port from host if present\n\n\n          var hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      var matcher = new RegExp(\"^\".concat(hasItem.value, \"$\"));\n      var matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(function (groupKey) {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (value.includes(\":\".concat(key))) {\n      value = value.replace(new RegExp(\":\".concat(key, \"\\\\*\"), 'g'), \":\".concat(key, \"--ESCAPED_PARAM_ASTERISKS\")).replace(new RegExp(\":\".concat(key, \"\\\\?\"), 'g'), \":\".concat(key, \"--ESCAPED_PARAM_QUESTION\")).replace(new RegExp(\":\".concat(key, \"\\\\+\"), 'g'), \":\".concat(key, \"--ESCAPED_PARAM_PLUS\")).replace(new RegExp(\":\".concat(key, \"(?!\\\\w)\"), 'g'), \"--ESCAPED_PARAM_COLON\".concat(key));\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return (0, _pathToRegexp).compile(\"/\".concat(value), {\n    validate: false\n  })(params).slice(1);\n}\n\nfunction prepareDestination(args) {\n  var query = Object.assign({}, args.query);\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  delete query.__nextDataReq;\n  var escapedDestination = args.destination;\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(_extends({}, args.params, query)); _i2 < _Object$keys2.length; _i2++) {\n    var param = _Object$keys2[_i2];\n    escapedDestination = escapeSegment(escapedDestination, param);\n  }\n\n  var parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n  var destQuery = parsedDestination.query;\n  var destPath = unescapeSegments(\"\".concat(parsedDestination.pathname).concat(parsedDestination.hash || ''));\n  var destHostname = unescapeSegments(parsedDestination.hostname || '');\n  var destPathParamKeys = [];\n  var destHostnameParamKeys = [];\n  (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n  (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n  var destParams = [];\n  destPathParamKeys.forEach(function (key) {\n    return destParams.push(key.name);\n  });\n  destHostnameParamKeys.forEach(function (key) {\n    return destParams.push(key.name);\n  });\n  var destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  var destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n    validate: false\n  }); // update any params in query values\n\n  for (var _i3 = 0, _Object$entries = Object.entries(destQuery); _i3 < _Object$entries.length; _i3++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),\n        key1 = _Object$entries$_i[0],\n        strOrArray = _Object$entries$_i[1];\n\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key1] = strOrArray.map(function (value) {\n        return compileNonPath(unescapeSegments(value), args.params);\n      });\n    } else {\n      destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  var paramKeys = Object.keys(args.params).filter(function (name) {\n    return name !== 'nextInternalLocale';\n  });\n\n  if (args.appendParamsToQuery && !paramKeys.some(function (key) {\n    return destParams.includes(key);\n  })) {\n    var _iterator = _createForOfIteratorHelper(paramKeys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n\n        if (!(key in destQuery)) {\n          destQuery[key] = args.params[key];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var newUrl;\n\n  try {\n    newUrl = destPathCompiler(args.params);\n\n    var _newUrl$split = newUrl.split('#'),\n        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),\n        pathname = _newUrl$split2[0],\n        hash = _newUrl$split2[1];\n\n    parsedDestination.hostname = destHostnameCompiler(args.params);\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = \"\".concat(hash ? '#' : '').concat(hash || '');\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match\");\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = _extends({}, query, parsedDestination.query);\n  return {\n    newUrl: newUrl,\n    destQuery: destQuery,\n    parsedDestination: parsedDestination\n  };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\n\n\nfunction getSafeParamName(paramName) {\n  var newParamName = '';\n\n  for (var i = 0; i < paramName.length; i++) {\n    var charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n\n  return newParamName;\n}\n\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(\":\".concat((0, _escapeRegexp).escapeStringRegexp(segmentName)), 'g'), \"__ESC_COLON_\".concat(segmentName));\n}\n\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, ':');\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/prepare-destination.ts"],"names":["matchHas","req","has","query","params","allMatch","every","hasItem","value","key","type","toLowerCase","headers","cookies","host","hostname","split","getSafeParamName","matcher","RegExp","matches","Array","isArray","slice","match","groups","Object","keys","forEach","groupKey","compileNonPath","includes","replace","compile","validate","prepareDestination","args","assign","__nextLocale","__nextDefaultLocale","__nextDataReq","escapedDestination","destination","param","escapeSegment","parsedDestination","parseUrl","destQuery","destPath","unescapeSegments","pathname","hash","destHostname","destPathParamKeys","destHostnameParamKeys","pathToRegexp","destParams","push","name","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","some","newUrl","search","err","message","Error","paramName","newParamName","i","length","charCode","charCodeAt","str","segmentName","escapeStringRegexp"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _parseUrl = require(\"./parse-url\");\nfunction matchHas(req, has, query) {\n    const params = {};\n    const allMatch = has.every((hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case 'header':\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case 'cookie':\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case 'query':\n                {\n                    value = query[key];\n                    break;\n                }\n            case 'host':\n                {\n                    const { host  } = (req == null ? void 0 : req.headers) || {};\n                    // remove port from host if present\n                    const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(`^${hasItem.value}$`);\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === 'host' && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    });\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(':')) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(`:${key}`)) {\n            value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathToRegexp).compile(`/${value}`, {\n        validate: false\n    })(params).slice(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({}, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    delete query.__nextDataReq;\n    let escapedDestination = args.destination;\n    for (const param of Object.keys(_extends({}, args.params, query))){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n    const destHostname = unescapeSegments(parsedDestination.hostname || '');\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name));\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name));\n    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key1, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key1] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params));\n        } else {\n            destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale');\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key))) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split('#');\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = _extends({}, query, parsedDestination.query);\n    return {\n        newUrl,\n        destQuery,\n        parsedDestination\n    };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = '';\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, ':');\n}\n\n//# sourceMappingURL=prepare-destination.js.map"]},"metadata":{},"sourceType":"script"}