{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nvar hasIntersectionObserver = typeof IntersectionObserver === 'function';\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n  var id = {\n    root: options.root || null,\n    margin: options.rootMargin || ''\n  };\n  var existing = idList.find(function (obj) {\n    return obj.root === id.root && obj.margin === id.margin;\n  });\n  var instance;\n  if (existing) {\n    instance = observers.get(existing);\n    if (instance) {\n      return instance;\n    }\n  }\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n    id = _createObserver.id,\n    observer = _createObserver.observer,\n    elements = _createObserver.elements;\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element);\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      var index = idList.findIndex(function (obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n      });\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\nfunction useIntersection(_ref) {\n  var rootRef = _ref.rootRef,\n    rootMargin = _ref.rootMargin,\n    disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var _useState = (0, _react).useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    visible = _useState2[0],\n    setVisible = _useState2[1];\n  var _useState3 = (0, _react).useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    element = _useState4[0],\n    setElement = _useState4[1];\n  (0, _react).useEffect(function () {\n    if (hasIntersectionObserver) {\n      if (isDisabled || visible) return;\n      if (element && element.tagName) {\n        var unobserve = observe(element, function (isVisible) {\n          return isVisible && setVisible(isVisible);\n        }, {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin: rootMargin\n        });\n        return unobserve;\n      }\n    } else {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [element, isDisabled, rootMargin, rootRef, visible]);\n  var resetVisible = (0, _react).useCallback(function () {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":["hasIntersectionObserver","IntersectionObserver","observers","Map","idList","createObserver","options","id","root","margin","rootMargin","existing","find","obj","instance","get","elements","observer","entries","forEach","entry","callback","target","isVisible","isIntersecting","intersectionRatio","push","set","observe","element","unobserve","delete","size","disconnect","index","findIndex","splice","useIntersection","rootRef","disabled","isDisabled","visible","setVisible","useState","setElement","useEffect","tagName","current","idleCallback","requestIdleCallback","cancelIdleCallback","resetVisible","useCallback"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function';\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection({ rootRef , rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react).useState(false);\n    const [element, setElement] = (0, _react).useState(null);\n    (0, _react).useEffect(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true));\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n            }\n        }\n    }, [\n        element,\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible\n    ]);\n    const resetVisible = (0, _react).useCallback(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-intersection.js.map"]},"metadata":{},"sourceType":"script"}