{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samuel.olvera/Documents/sites/htdocs/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samuel.olvera/Documents/sites/htdocs/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/samuel.olvera/Documents/sites/htdocs/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports.default = void 0;\n\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\n\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\n\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\n\nvar _removeTrailingSlash = require(\"./utils/remove-trailing-slash\");\n\nvar _routeLoader = require(\"../../../client/route-loader\");\n\nvar _script = require(\"../../../client/script\");\n\nvar _isError = _interop_require_wildcard(require(\"../../../lib/is-error\"));\n\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\n\nvar _mitt = _interop_require_default(require(\"../mitt\"));\n\nvar _utils = require(\"../utils\");\n\nvar _isDynamic = require(\"./utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\n\nvar _querystring = require(\"./utils/querystring\");\n\nvar _resolveRewrites = _interop_require_default(require(\"./utils/resolve-rewrites\"));\n\nvar _routeMatcher = require(\"./utils/route-matcher\");\n\nvar _routeRegex = require(\"./utils/route-regex\");\n\nvar _formatUrl = require(\"./utils/format-url\");\n\nvar _detectDomainLocale = require(\"../../../client/detect-domain-locale\");\n\nvar _parsePath = require(\"./utils/parse-path\");\n\nvar _addLocale = require(\"../../../client/add-locale\");\n\nvar _removeLocale = require(\"../../../client/remove-locale\");\n\nvar _removeBasePath = require(\"../../../client/remove-base-path\");\n\nvar _addBasePath = require(\"../../../client/add-base-path\");\n\nvar _hasBasePath = require(\"../../../client/has-base-path\");\n\nvar _getNextPathnameInfo = require(\"./utils/get-next-pathname-info\");\n\nvar _formatNextPathnameInfo = require(\"./utils/format-next-pathname-info\");\n\nvar _compareStates = require(\"./utils/compare-states\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!(0, _utils).isAbsoluteUrl(url)) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    var locationOrigin = (0, _utils).getLocationOrigin();\n    var resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  var interpolatedRoute = '';\n  var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  var dynamicGroups = dynamicRegex.groups;\n  var dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  var params = Object.keys(dynamicGroups);\n\n  if (!params.every(function (param) {\n    var value = dynamicMatches[param] || '';\n    var _dynamicGroups$param = dynamicGroups[param],\n        repeat = _dynamicGroups$param.repeat,\n        optional = _dynamicGroups$param.optional; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n\n    if (optional) {\n      replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    function (segment) {\n      return encodeURIComponent(segment);\n    }).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ; // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params: params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omit(object, keys) {\n  var omitted = {};\n  Object.keys(object).forEach(function (key) {\n    if (!keys.includes(key)) {\n      omitted[key] = object[key];\n    }\n  });\n  return omitted;\n}\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  var base;\n  var urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  var urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  var urlParts = urlAsStringNoProto.split('?');\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n    var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    var finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    var interpolatedAs = '';\n\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n\n      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),\n          result = _interpolateAs.result,\n          params = _interpolateAs.params;\n\n      if (result) {\n        interpolatedAs = (0, _formatUrl).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omit(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _resolveHref = resolveHref(router, url, true),\n      _resolveHref2 = _slicedToArray(_resolveHref, 2),\n      resolvedHref = _resolveHref2[0],\n      resolvedAs = _resolveHref2[1];\n\n  var origin = (0, _utils).getLocationOrigin();\n  var hrefHadOrigin = resolvedHref.startsWith(origin);\n  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n  var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\n\nvar manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    var v = '__next'; // eslint-disable-next-line no-sequences\n\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1'\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nvar backgroundCache = {};\n\nfunction fetchNextData(_ref) {\n  var dataHref = _ref.dataHref,\n      inflightCache = _ref.inflightCache,\n      isPrefetch = _ref.isPrefetch,\n      hasMiddleware = _ref.hasMiddleware,\n      isServerRender = _ref.isServerRender,\n      parseJSON = _ref.parseJSON,\n      persistCache = _ref.persistCache,\n      isBackground = _ref.isBackground,\n      unstable_skipClientCache = _ref.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var ref1;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: isPrefetch ? {\n        purpose: 'prefetch'\n      } : {},\n      method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: '',\n          json: {}\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {}\n            };\n          }\n\n          if (!hasMiddleware && response.status === 404) {\n            var ref;\n\n            if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeLoader).markAssetError(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    }).catch(function (err) {\n      delete inflightCache[cacheKey];\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: 'HEAD'\n  } : {});\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(_ref2) {\n  var url = _ref2.url,\n      router = _ref2.router;\n\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(_ref3) {\n  var route = _ref3.route,\n      router = _ref3.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname1, query1, as1, _ref4) {\n    var _this2 = this;\n\n    var initialProps = _ref4.initialProps,\n        pageLoader = _ref4.pageLoader,\n        App = _ref4.App,\n        wrapApp = _ref4.wrapApp,\n        Component = _ref4.Component,\n        err = _ref4.err,\n        subscription = _ref4.subscription,\n        isFallback = _ref4.isFallback,\n        locale = _ref4.locale,\n        locales = _ref4.locales,\n        defaultLocale = _ref4.defaultLocale,\n        domainLocales = _ref4.domainLocales,\n        isPreview = _ref4.isPreview,\n        isRsc = _ref4.isRsc;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache\n    this.sdc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this2.isFirstPopStateEvent;\n      _this2.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname = _this2.pathname,\n            query = _this2.query;\n\n        _this2.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n          pathname: (0, _addBasePath).addBasePath(_pathname),\n          query: query\n        }), (0, _utils).getURL());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this2.locale === state.options.locale && state.as === _this2.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (_this2._key !== key) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + _this2._key, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (e) {} // Restore old scroll position:\n\n\n            try {\n              var v = sessionStorage.getItem('__next_scroll_' + key);\n              forcedScroll = JSON.parse(v);\n            } catch (e1) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n\n      _this2._key = key;\n\n      var _parseRelativeUrl2 = (0, _parseRelativeUrl).parseRelativeUrl(url),\n          pathname = _parseRelativeUrl2.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this2.isSsr && as === (0, _addBasePath).addBasePath(_this2.asPath) && pathname === (0, _addBasePath).addBasePath(_this2.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this2._bps && !_this2._bps(state)) {\n        return;\n      }\n\n      _this2.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this2._shallow,\n        locale: options.locale || _this2.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname1 !== '/_error') {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n        __N_RSC: !!isRsc\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);\n    }\n\n    this.state = {\n      route: route,\n      pathname: pathname1,\n      query: query1,\n      asPath: autoExportDynamic ? pathname1 : as1,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as1.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils).getURL();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as1 !== pathname1;\n\n          _this2.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({\n            pathname: (0, _addBasePath).addBasePath(pathname1),\n            query: query1\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        // TODO: remove in the future when we update history before route change\n        // is complete, as the popstate event should handle this capture.\n        if (manualScrollRestoration) {\n          try {\n            // Snapshot scroll position right before navigating to a new page:\n            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n              x: self.pageXOffset,\n              y: self.pageYOffset\n            }));\n          } catch (e) {}\n        }\n      }\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change('pushState', url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change('replaceState', url, as, options);\n    }\n  }, {\n    key: \"change\",\n    value: function change(method, url, as, options, forcedScroll) {\n      var _this = this;\n\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, isMiddlewareMatch, rewritesResult, route, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, ref2, ref3, routeInfo, prefixedAs, rewriteAs, localeResult, _routeRegex2, curRouteMatch, _routeInfo, error, props, __N_SSG, __N_SSP, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _route, isValidShallowRoute, _scroll, shouldScroll, resetScroll, upcomingRouterState, upcomingScrollState, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (isLocalURL(url)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h;\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n                nextState = _extends({}, _this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = _this.isReady !== true;\n                _this.isReady = true;\n                isSsr = _this.isSsr;\n\n                if (!isQueryUpdating) {\n                  _this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && _this.clc)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 12:\n                prevLocale = nextState.locale;\n\n                if (!process.env.__NEXT_I18N_SUPPORT) {\n                  _context.next = 25;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === 'undefined') {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);\n                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);\n                  as = (0, _formatUrl).formatWithValidation(parsedAs);\n                  url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  // if the locale isn't configured hard navigate to show 404 page\n                  if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {\n                    parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);\n                    handleHardNavigation({\n                      url: (0, _formatUrl).formatWithValidation(parsedAs),\n                      router: _this\n                    }); // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n\n                    didNavigate = true;\n                  }\n                }\n\n                detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  // if we are navigating to a domain locale ensure we redirect to the\n                  // correct domain\n                  if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    asNoBasePath = (0, _removeBasePath).removeBasePath(as);\n                    handleHardNavigation({\n                      url: \"http\".concat(detectedDomain.http ? '' : 's', \"://\").concat(detectedDomain.domain).concat((0, _addBasePath).addBasePath(\"\".concat(nextState.locale === detectedDomain.defaultLocale ? '' : \"/\".concat(nextState.locale)).concat(asNoBasePath === '/' ? '' : asNoBasePath) || '/')),\n                      router: _this\n                    }); // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n\n                    didNavigate = true;\n                  }\n                }\n\n                if (!didNavigate) {\n                  _context.next = 25;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 25:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark('routeChange');\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (_this._inFlightRoute && _this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                  }\n\n                  _this.clc();\n\n                  _this.clc = null;\n                }\n\n                as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n                cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n                _this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context.next = 49;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                _this.changeState(method, url, as, _extends({}, options, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  _this.scrollToHash(cleanedAs);\n                }\n\n                _context.prev = 38;\n                _context.next = 41;\n                return _this.set(nextState, _this.components[nextState.route], null);\n\n              case 41:\n                _context.next = 47;\n                break;\n\n              case 43:\n                _context.prev = 43;\n                _context.t0 = _context[\"catch\"](38);\n\n                if ((0, _isError).default(_context.t0) && _context.t0.cancelled) {\n                  Router.events.emit('routeChangeError', _context.t0, cleanedAs, routeProps);\n                }\n\n                throw _context.t0;\n\n              case 47:\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return _context.abrupt(\"return\", true);\n\n              case 49:\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages\n                // get their query parameters to allow ensuring they can be parsed properly\n                // when rewritten to\n\n                _context.prev = 51;\n                _context.next = 54;\n                return Promise.all([_this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), _this.pageLoader.getMiddleware()]);\n\n              case 54:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context.next = 64;\n                break;\n\n              case 60:\n                _context.prev = 60;\n                _context.t1 = _context[\"catch\"](51);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", false);\n\n              case 64:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = 'replaceState';\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname; // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context.next = 69;\n                return matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: _this\n                });\n\n              case 69:\n                isMiddlewareMatch = _context.sent;\n\n                if (options.shallow && isMiddlewareMatch) {\n                  pathname = _this.pathname;\n                }\n\n                if (!(shouldResolveHref && pathname !== '/_error')) {\n                  _context.next = 84;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (!(process.env.__NEXT_HAS_REWRITES && as.startsWith('/'))) {\n                  _context.next = 82;\n                  break;\n                }\n\n                rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context.next = 78;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", true);\n\n              case 78:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                }\n\n                _context.next = 84;\n                break;\n\n              case 82:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                }\n\n              case 84:\n                if (isLocalURL(as)) {\n                  _context.next = 89;\n                  break;\n                }\n\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context.next = 87;\n                  break;\n                }\n\n                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 87:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", false);\n\n              case 89:\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                routeMatch = false;\n\n                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                  _context.next = 107;\n                  break;\n                }\n\n                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context.next = 106;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param];\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context.next = 104;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n\n              case 104:\n                _context.next = 107;\n                break;\n\n              case 106:\n                if (shouldInterpolate) {\n                  as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omit(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 107:\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeStart', as, routeProps);\n                }\n\n                _context.prev = 108;\n                _context.next = 111;\n                return _this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch\n                });\n\n              case 111:\n                routeInfo = _context.sent;\n\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  if (routeMatch && pathname !== parsed.pathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                      rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                    }\n\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                      localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);\n                      nextState.locale = localeResult.detectedLocale || nextState.locale;\n                      rewriteAs = localeResult.pathname;\n                    }\n\n                    _routeRegex2 = (0, _routeRegex).getRouteRegex(pathname);\n                    curRouteMatch = (0, _routeMatcher).getRouteMatcher(_routeRegex2)(rewriteAs);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!('type' in routeInfo)) {\n                  _context.next = 120;\n                  break;\n                }\n\n                if (!(routeInfo.type === 'redirect-internal')) {\n                  _context.next = 118;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", _this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 118:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 120:\n                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP;\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script).handleClientScriptLoad(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((__N_SSG || __N_SSP) && props)) {\n                  _context.next = 150;\n                  break;\n                }\n\n                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                  _context.next = 134;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context.next = 132;\n                  break;\n                }\n\n                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context.abrupt(\"return\", _this.change(method, newUrl, newAs, options));\n\n              case 132:\n                handleHardNavigation({\n                  url: destination,\n                  router: _this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 134:\n                nextState.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context.next = 150;\n                  break;\n                }\n\n                _context.prev = 136;\n                _context.next = 139;\n                return _this.fetchComponent('/404');\n\n              case 139:\n                notFoundRoute = '/404';\n                _context.next = 145;\n                break;\n\n              case 142:\n                _context.prev = 142;\n                _context.t2 = _context[\"catch\"](136);\n                notFoundRoute = '/_error';\n\n              case 145:\n                _context.next = 147;\n                return _this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview\n                });\n\n              case 147:\n                routeInfo = _context.sent;\n\n                if (!('type' in routeInfo)) {\n                  _context.next = 150;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 150:\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n\n                _this.changeState(method, url, as, options);\n\n                if (isQueryUpdating && pathname === '/_error' && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null; // the new state that the router gonna set\n\n                upcomingRouterState = _extends({}, nextState, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                });\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n                canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n\n                if (canSkipUpdating) {\n                  _context.next = 169;\n                  break;\n                }\n\n                _context.next = 162;\n                return _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch(function (e) {\n                  if (e.cancelled) error = error || e;else throw e;\n                });\n\n              case 162:\n                if (!error) {\n                  _context.next = 165;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                }\n\n                throw error;\n\n              case 165:\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  if (nextState.locale) {\n                    document.documentElement.lang = nextState.locale;\n                  }\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeComplete', as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  _this.scrollToHash(as);\n                }\n\n              case 169:\n                return _context.abrupt(\"return\", true);\n\n              case 172:\n                _context.prev = 172;\n                _context.t3 = _context[\"catch\"](108);\n\n                if (!((0, _isError).default(_context.t3) && _context.t3.cancelled)) {\n                  _context.next = 176;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 176:\n                throw _context.t3;\n\n              case 177:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[38, 43], [51, 60], [108, 172], [136, 142]]);\n      }))();\n    }\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof window.history === 'undefined') {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === 'undefined') {\n          console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n          return;\n        }\n      }\n\n      if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== 'pushState' ? this._key : createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        '', as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n      var _this = this;\n\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var props, _yield$_this$fetchCom, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context2.prev = 7;\n                _context2.next = 10;\n                return _this.fetchComponent('/_error');\n\n              case 10:\n                _yield$_this$fetchCom = _context2.sent;\n                Component = _yield$_this$fetchCom.page;\n                styleSheets = _yield$_this$fetchCom.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                _context2.prev = 15;\n                _context2.next = 18;\n                return _this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context2.sent;\n                _context2.next = 25;\n                break;\n\n              case 21:\n                _context2.prev = 21;\n                _context2.t0 = _context2[\"catch\"](15);\n                console.error('Error in error page `getInitialProps`: ', _context2.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context2.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context2.prev = 28;\n                _context2.t1 = _context2[\"catch\"](7);\n                return _context2.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).default(_context2.t1) ? _context2.t1 : new Error(_context2.t1 + ''), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[7, 28], [15, 21]]);\n      }))();\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(_ref5) {\n      var requestedRoute = _ref5.route,\n          pathname = _ref5.pathname,\n          query = _ref5.query,\n          as = _ref5.as,\n          resolvedAs = _ref5.resolvedAs,\n          routeProps = _ref5.routeProps,\n          locale = _ref5.locale,\n          hasMiddleware = _ref5.hasMiddleware,\n          isPreview = _ref5.isPreview,\n          unstable_skipClientCache = _ref5.unstable_skipClientCache;\n\n      var _this = this;\n\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var route, ref, ref4, ref5, handleCancelled, existingInfo, cachedRouteInfo, fetchNextDataParams, data, routeInfo, _require, isValidElementType, useStreamedFlightData, shouldFetchData, _yield$_this$_getData, props, cacheKey, flightInfo;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n                route = requestedRoute;\n                _context4.prev = 1;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                existingInfo = _this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && _this.route === route)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", existingInfo);\n\n              case 6:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n                fetchNextDataParams = {\n                  dataHref: _this.pageLoader.getDataHref({\n                    href: (0, _formatUrl).formatWithValidation({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: _this.isSsr,\n                  parseJSON: true,\n                  inflightCache: _this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache\n                };\n                _context4.next = 11;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: resolvedAs,\n                  locale: locale,\n                  router: _this\n                });\n\n              case 11:\n                data = _context4.sent;\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === 'redirect-external')) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", data.effect);\n\n              case 15:\n                if (!((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === 'rewrite')) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                route = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                pathname = data.effect.resolvedHref;\n                query = _extends({}, query, data.effect.parsedAs.query);\n                resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = _this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware)) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", _extends({}, existingInfo, {\n                  route: route\n                }));\n\n              case 23:\n                if (!(route === '/api' || route.startsWith('/api/'))) {\n                  _context4.next = 26;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", new Promise(function () {}));\n\n              case 26:\n                _context4.t0 = cachedRouteInfo;\n\n                if (_context4.t0) {\n                  _context4.next = 31;\n                  break;\n                }\n\n                _context4.next = 30;\n                return _this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP,\n                    __N_RSC: !!res.mod.__next_rsc__\n                  };\n                });\n\n              case 30:\n                _context4.t0 = _context4.sent;\n\n              case 31:\n                routeInfo = _context4.t0;\n\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context4.next = 36;\n                  break;\n                }\n\n                _require = require('next/dist/compiled/react-is'), isValidElementType = _require.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context4.next = 36;\n                  break;\n                }\n\n                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n\n              case 36:\n                /**\n                * For server components, non-SSR pages will have statically optimized\n                * flight data in a production build. So only development and SSR pages\n                * will always have the real-time generated and streamed flight data.\n                */\n                useStreamedFlightData = routeInfo.__N_RSC && (process.env.NODE_ENV !== 'production' || routeInfo.__N_SSP);\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP || routeInfo.__N_RSC;\n                _context4.next = 40;\n                return _this._getData(_async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var _ref6, json;\n\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!(shouldFetchData && !useStreamedFlightData)) {\n                            _context3.next = 11;\n                            break;\n                          }\n\n                          if (!(data == null ? void 0 : data.json)) {\n                            _context3.next = 5;\n                            break;\n                          }\n\n                          _context3.t0 = data;\n                          _context3.next = 8;\n                          break;\n\n                        case 5:\n                          _context3.next = 7;\n                          return fetchNextData({\n                            dataHref: _this.pageLoader.getDataHref({\n                              href: (0, _formatUrl).formatWithValidation({\n                                pathname: pathname,\n                                query: query\n                              }),\n                              asPath: resolvedAs,\n                              locale: locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 7:\n                          _context3.t0 = _context3.sent;\n\n                        case 8:\n                          _ref6 = _context3.t0;\n                          json = _ref6.json;\n                          return _context3.abrupt(\"return\", {\n                            props: json || {}\n                          });\n\n                        case 11:\n                          _context3.t1 = {};\n                          _context3.next = 14;\n                          return _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                          });\n\n                        case 14:\n                          _context3.t2 = _context3.sent;\n                          return _context3.abrupt(\"return\", {\n                            headers: _context3.t1,\n                            props: _context3.t2\n                          });\n\n                        case 16:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                })));\n\n              case 40:\n                _yield$_this$_getData = _context4.sent;\n                props = _yield$_this$_getData.props;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                  cacheKey = new URL(fetchNextDataParams.dataHref, window.location.href).href;\n                  delete _this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!_this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development') {\n                  fetchNextData(Object.assign({}, fetchNextDataParams, {\n                    isBackground: true,\n                    persistCache: false,\n                    inflightCache: backgroundCache\n                  })).catch(function () {});\n                }\n\n                if (!routeInfo.__N_RSC) {\n                  _context4.next = 54;\n                  break;\n                }\n\n                if (!useStreamedFlightData) {\n                  _context4.next = 51;\n                  break;\n                }\n\n                _context4.next = 48;\n                return _this._getData(function () {\n                  return _this._getFlightData((0, _formatUrl).formatWithValidation({\n                    query: _extends({}, query, {\n                      __flight__: '1'\n                    }),\n                    pathname: (0, _isDynamic).isDynamicRoute(route) ? interpolateAs(pathname, (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs).pathname, query).result : pathname\n                  }));\n                });\n\n              case 48:\n                _context4.t1 = _context4.sent.data;\n                _context4.next = 52;\n                break;\n\n              case 51:\n                _context4.t1 = props.__flight__;\n\n              case 52:\n                _context4.t2 = _context4.t1;\n                flightInfo = {\n                  __flight__: _context4.t2\n                };\n\n              case 54:\n                props.pageProps = Object.assign({}, props.pageProps, flightInfo);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return _context4.abrupt(\"return\", routeInfo);\n\n              case 63:\n                _context4.prev = 63;\n                _context4.t3 = _context4[\"catch\"](1);\n                return _context4.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).getProperError(_context4.t3), pathname, query, as, routeProps));\n\n              case 66:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[1, 63]]);\n      }))();\n    }\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split('#'),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split('#'),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split('#'),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? '' : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === '' || hash === 'top') {\n        window.scrollTo(0, 0);\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(url) {\n      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _this = this;\n\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield$getClientBuild, rewritesResult, data, route;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query;\n\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  if (options.locale === false) {\n                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                    parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                    localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                    parsedAs.pathname = localePathResult.pathname;\n                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;\n                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n                  }\n                }\n\n                _context5.next = 5;\n                return _this.pageLoader.getPageList();\n\n              case 5:\n                pages = _context5.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n                _context5.next = 10;\n                return matchesMiddleware({\n                  asPath: asPath,\n                  locale: locale,\n                  router: _this\n                });\n\n              case 10:\n                isMiddlewareMatch = _context5.sent;\n\n                if (!(process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/'))) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                _context5.next = 14;\n                return (0, _routeLoader).getClientBuildManifest();\n\n              case 14:\n                _yield$getClientBuild = _context5.sent;\n                rewrites = _yield$getClientBuild.__rewrites;\n                rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 19:\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                }\n\n              case 21:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 25:\n                _context5.next = 27;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                          pathname: pathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this.sdc,\n                      persistCache: !_this.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: _this\n                });\n\n              case 27:\n                data = _context5.sent;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _extends({}, query, data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === 'redirect-external')) {\n                  _context5.next = 31;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 31:\n                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                _context5.next = 34;\n                return Promise.all([_this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.dataHref) || _this.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !_this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                  }).then(function () {\n                    return false;\n                  }) : false;\n                }), _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n\n              case 34:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    }\n  }, {\n    key: \"fetchComponent\",\n    value: function fetchComponent(route) {\n      var _this = this;\n\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                _context6.prev = 1;\n                _context6.next = 4;\n                return _this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context6.sent;\n                handleCancelled();\n                return _context6.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](1);\n                handleCancelled();\n                throw _context6.t0;\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[1, 9]]);\n      }))();\n    }\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this3 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this3.clc) {\n          _this3.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error('Loading initial props cancelled');\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (_ref7) {\n        var text = _ref7.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components['/_app'].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils).loadGetInitialProps(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\nRouter.events = (0, _mitt).default();\n\nfunction matchesMiddleware(options) {\n  return Promise.resolve(options.router.pageLoader.getMiddleware()).then(function (middleware) {\n    var _parsePath2 = (0, _parsePath).parsePath(options.asPath),\n        asPathname = _parsePath2.pathname;\n\n    var cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n    var regex = middleware == null ? void 0 : middleware.location;\n    return !!regex && new RegExp(regex).test((0, _addLocale).addLocale(cleanedAs, options.locale));\n  });\n}\n\nfunction withMiddlewareEffects(options) {\n  return matchesMiddleware(options).then(function (matches) {\n    if (matches && options.fetchData) {\n      return options.fetchData().then(function (data) {\n        return getMiddlewareData(data.dataHref, data.response, options).then(function (effect) {\n          return {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            effect: effect\n          };\n        });\n      }).catch(function (_err) {\n        /**\n        * TODO: Revisit this in the future.\n        * For now we will not consider middleware data errors to be fatal.\n        * maybe we should revisit in the future.\n        */\n        return null;\n      });\n    }\n\n    return null;\n  });\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n  };\n  var rewriteHeader = response.headers.get('x-nextjs-rewrite');\n  var rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n  var matchedPath = response.headers.get('x-matched-path');\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith('/')) {\n      var parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n      var pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest()]).then(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            pages = _ref9[0],\n            rewrites = _ref9[1].__rewrites;\n\n        var as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (process.env.__NEXT_HAS_REWRITES) {\n          var result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, function (path) {\n            return resolveDynamicRoute(path, pages);\n          }, options.router.locales);\n\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname;\n            as = parsedRewriteTarget.pathname;\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n          }\n        } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n          var matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: 'rewrite',\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsePath).parsePath(source);\n    var pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    }), {\n      defaultLocale: options.router.defaultLocale,\n      buildId: ''\n    }));\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n    });\n  }\n\n  var redirectTarget = response.headers.get('x-nextjs-redirect');\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      var _src = (0, _parsePath).parsePath(redirectTarget);\n\n      var _pathname2 = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      }), {\n        defaultLocale: options.router.defaultLocale,\n        buildId: ''\n      }));\n\n      return Promise.resolve({\n        type: 'redirect-internal',\n        newAs: \"\".concat(_pathname2).concat(_src.query).concat(_src.hash),\n        newUrl: \"\".concat(_pathname2).concat(_src.query).concat(_src.hash)\n      });\n    }\n\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: 'next'\n  });\n}\n\nexports.default = Router;","map":{"version":3,"sources":["../../../../shared/lib/router/router.ts"],"names":["buildCancellationError","Object","assign","Error","cancelled","isLocalURL","url","isAbsoluteUrl","locationOrigin","getLocationOrigin","resolved","URL","origin","hasBasePath","pathname","_","interpolateAs","route","asPathname","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","keys","every","param","value","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result","omit","object","omitted","forEach","key","includes","resolveHref","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","normalizedUrl","normalizeRepeatedSlashes","startsWith","asPath","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","searchParamsToUrlQuery","hash","resolvedHref","stripOrigin","substring","prepareUrlAs","as","resolvedAs","hrefHadOrigin","asHadOrigin","preparedUrl","addBasePath","preparedAs","resolveDynamicRoute","pages","cleanPathname","removeTrailingSlash","denormalizePagePath","some","page","re","test","manualScrollRestoration","process","env","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","options","fetch","credentials","method","headers","then","response","ok","status","backgroundCache","fetchNextData","dataHref","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","cacheKey","location","getData","purpose","text","json","tryToParseAsJSON","notFound","markAssetError","data","NODE_ENV","get","catch","err","Promise","resolve","undefined","JSON","parse","createKey","Math","random","toString","handleHardNavigation","addLocale","locale","getCancelledHandler","cancel","clc","handleCancelled","Router","sdc","isFirstPopStateEvent","_key","events","mitt","constructor","initialProps","pageLoader","App","wrapApp","Component","subscription","isFallback","locales","defaultLocale","domainLocales","isPreview","isRsc","components","initial","props","__N_SSG","__N_SSP","__N_RSC","styleSheets","autoExportDynamic","self","__NEXT_DATA__","autoExport","basePath","__NEXT_ROUTER_BASEPATH","sub","_wrapApp","isSsr","isLocaleDomain","isReady","gssp","gip","appGip","gsp","search","__NEXT_HAS_REWRITES","__NEXT_I18N_SUPPORT","detectDomainLocale","hostname","state","_initialMatchesMiddlewarePromise","getURL","matchesMiddleware","matches","_shouldResolveHref","changeState","addEventListener","onPopState","scrollRestoration","e","__NA","reload","__N","forcedScroll","stringify","x","pageXOffset","y","pageYOffset","getItem","parseRelativeUrl","_bps","change","shallow","_shallow","_h","back","push","isQueryUpdating","shouldResolveHref","parsePath","nextState","readyStateChange","prevLocale","parsedAs","removeBasePath","localePathResult","normalizeLocalePath","detectedLocale","didNavigate","detectedDomain","domain","asNoBasePath","http","ST","performance","mark","scroll","routeProps","_inFlightRoute","emit","cleanedAs","removeLocale","localeChange","onlyAHashChange","scrollToHash","set","isError","parsed","__rewrites","rewrites","all","getPageList","getClientBuildManifest","getMiddleware","urlIsNew","isMiddlewareMatch","rewritesResult","resolveRewrites","p","externalDest","matchedPage","routeMatch","routeRegex","shouldInterpolate","missingParams","filter","warn","routeInfo","getRouteInfo","prefixedAs","rewriteAs","localeResult","curRouteMatch","type","newUrl","newAs","destination","component","unstable_scriptLoader","scripts","concat","script","handleClientScriptLoad","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","fetchComponent","notFoundRoute","statusCode","isValidShallowRoute","shouldScroll","resetScroll","upcomingRouterState","upcomingScrollState","canSkipUpdating","compareRouterStates","document","documentElement","lang","hashRegex","handleRouteInfoError","loadErrorFail","isAssetError","getInitialProps","routeInfoErr","requestedRoute","existingInfo","cachedRouteInfo","fetchNextDataParams","getDataHref","skipInterpolation","withMiddlewareEffects","fetchData","effect","res","mod","__next_rsc__","isValidElementType","require","useStreamedFlightData","shouldFetchData","_getData","flightInfo","__flight__","_getFlightData","getProperError","beforePopState","cb","oldUrlNoHash","oldHash","newUrlNoHash","newHash","scrollTo","rawHash","decodeURIComponent","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","prefetch","_isSsg","isSsg","priority","__NEXT_OPTIMISTIC_CLIENT_CACHE","componentResult","loadPage","fn","ctx","AppTree","loadGetInitialProps","middleware","regex","RegExp","getMiddlewareData","_err","source","nextConfig","i18n","trailingSlash","Boolean","__NEXT_TRAILING_SLASH","rewriteHeader","rewriteTarget","matchedPath","parsedRewriteTarget","pathnameInfo","getNextPathnameInfo","parseData","fsPathname","parsedSource","path","resolvedPathname","src","formatNextPathnameInfo","buildId","redirectTarget"],"mappings":"AACA;;;;;;;;;;;;;QAwFgBK,U,GAAAA,U;QAeAW,a,GAAAA,a;QAiFAiC,W,GAAAA,W;QAyXAqG,S,GAAAA,S;;;;;;;;;;;AAziB2B,IAAA,uBAA0C,GAAA,OAAA,CAA1C,0CAA0C,CAA1C;;AACP,IAAA,oBAA+B,GAAA,OAAA,CAA/B,+BAA+B,CAA/B;;AAK7B,IAAA,YAA8B,GAAA,OAAA,CAA9B,8BAA8B,CAA9B;;AACgC,IAAA,OAAwB,GAAA,OAAA,CAAxB,wBAAwB,CAAxB;;AACC,IAAA,QAAuB,GAAA,yBAAA,CAAA,OAAA,CAAvB,uBAAuB,CAAA,CAAvB;;AACJ,IAAA,oBAAoC,GAAA,OAAA,CAApC,oCAAoC,CAApC;;AACA,IAAA,oBAA+B,GAAA,OAAA,CAA/B,+BAA+B,CAA/B;;AACnB,IAAA,KAAS,GAAA,wBAAA,CAAA,OAAA,CAAT,SAAS,CAAA,CAAT;;AAWV,IAAA,MAAU,GAAA,OAAA,CAAV,UAAU,CAAV;;AACwB,IAAA,UAAoB,GAAA,OAAA,CAApB,oBAAoB,CAApB;;AACE,IAAA,iBAA4B,GAAA,OAAA,CAA5B,4BAA4B,CAA5B;;AACM,IAAA,YAAqB,GAAA,OAAA,CAArB,qBAAqB,CAArB;;AACX,IAAA,gBAA0B,GAAA,wBAAA,CAAA,OAAA,CAA1B,0BAA0B,CAAA,CAA1B;;AACI,IAAA,aAAuB,GAAA,OAAA,CAAvB,uBAAuB,CAAvB;;AACF,IAAA,WAAqB,GAAA,OAAA,CAArB,qBAAqB,CAArB;;AACO,IAAA,UAAoB,GAAA,OAAA,CAApB,oBAAoB,CAApB;;AACF,IAAA,mBAAsC,GAAA,OAAA,CAAtC,sCAAsC,CAAtC;;AACT,IAAA,UAAoB,GAAA,OAAA,CAApB,oBAAoB,CAApB;;AACA,IAAA,UAA4B,GAAA,OAAA,CAA5B,4BAA4B,CAA5B;;AACG,IAAA,aAA+B,GAAA,OAAA,CAA/B,+BAA+B,CAA/B;;AACE,IAAA,eAAkC,GAAA,OAAA,CAAlC,kCAAkC,CAAlC;;AACH,IAAA,YAA+B,GAAA,OAAA,CAA/B,+BAA+B,CAA/B;;AACA,IAAA,YAA+B,GAAA,OAAA,CAA/B,+BAA+B,CAA/B;;AACQ,IAAA,oBAAgC,GAAA,OAAA,CAAhC,gCAAgC,CAAhC;;AACG,IAAA,uBAAmC,GAAA,OAAA,CAAnC,mCAAmC,CAAnC;;AACH,IAAA,cAAwB,GAAA,OAAA,CAAxB,wBAAwB,CAAxB;;AAgCpC,SAAStJ,sBAAT,GAAkC;EAChC,OAAOC,MAAM,CAACC,MAAPD,CAAc,IAAIE,KAAJ,CAAU,iBAAV,CAAdF,EAA4C;IACjDG,SAAS,EAAE;EADsC,CAA5CH,CAAP;AAGD;;AAKM,SAASI,UAAT,CAAoBC,GAApB,EAA0C;EAC/C;EACA,IAAI,CAACC,CAAAA,GAAAA,MAAAA,EAAa,aAAbA,CAAcD,GAAdC,CAAL,EAAyB,OAAO,IAAP;;EACzB,IAAI;IACF;IACA,IAAMC,cAAc,GAAGC,CAAAA,GAAAA,MAAAA,EAAiB,iBAAjBA,EAAvB;IACA,IAAMC,QAAQ,GAAG,IAAIC,GAAJ,CAAQL,GAAR,EAAaE,cAAb,CAAjB;IACA,OAAOE,QAAQ,CAACE,MAATF,KAAoBF,cAApBE,IAAsCG,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYH,QAAQ,CAACI,QAArBD,CAA7C;EACD,CALD,CAKE,OAAOE,CAAP,EAAU;IACV,OAAO,KAAP;EACD;AACF;;AAIM,SAASC,aAAT,CACLC,KADK,EAELC,UAFK,EAGLC,KAHK,EAIL;EACA,IAAIC,iBAAiB,GAAG,EAAxB;EAEA,IAAMC,YAAY,GAAGC,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcL,KAAdK,CAArB;EACA,IAAMC,aAAa,GAAGF,YAAY,CAACG,MAAnC;EACA,IAAMC,cAAc,GAClB;EACA,CAACP,UAAU,KAAKD,KAAfC,GAAuBQ,CAAAA,GAAAA,aAAAA,EAAe,eAAfA,CAAgBL,YAAhBK,EAA8BR,UAA9BQ,CAAvBR,GAAmE,EAApE,KACA;EACA;EACAC,KALF;EAOAC,iBAAiB,GAAGH,KAApBG;EACA,IAAMO,MAAM,GAAG1B,MAAM,CAAC2B,IAAP3B,CAAYsB,aAAZtB,CAAf;;EAEA,IACE,CAAC0B,MAAM,CAACE,KAAPF,CAAa,UAACG,KAAD,EAAW;IACvB,IAAIC,KAAK,GAAGN,cAAc,CAACK,KAAD,CAAdL,IAAyB,EAArC;IACA,2BAA6BF,aAAa,CAACO,KAAD,CAA1C;IAAA,IAAQE,MAAR,wBAAQA,MAAR;IAAA,IAAgBC,QAAhB,wBAAgBA,QAAhB,CAFuB,CAIvB;IACA;;IACA,IAAIC,QAAQ,cAAOF,MAAM,GAAG,KAAH,GAAW,EAAxB,SAA6BF,KAA7B,MAAZ;;IACA,IAAIG,QAAJ,EAAc;MACZC,QAAQ,aAAM,CAACH,KAAD,GAAS,GAAT,GAAe,EAArB,cAA2BG,QAA3B,MAARA;IACD;;IACD,IAAIF,MAAM,IAAI,CAACG,KAAK,CAACC,OAAND,CAAcJ,KAAdI,CAAf,EAAqCJ,KAAK,GAAG,CAACA,KAAD,CAARA;IAErC,OACE,CAACE,QAAQ,IAAIH,KAAK,IAAIL,cAAtB,OACA;IACCL,iBAAiB,GAChBA,iBAAiB,CAAEiB,OAAnBjB,CACEc,QADFd,EAEEY,MAAM,GACDD,KAAK,CACHO,GADFP,EAEG;IACA;IACA;IACA;IACA,UAACQ,OAAD;MAAA,OAAaC,kBAAkB,CAACD,OAAD,CAA/B;IAAA,CANHR,EAQEU,IARFV,CAQO,GARPA,CADC,GAUFS,kBAAkB,CAACT,KAAD,CAZxBX,KAaK,GAhBP,CADF;EAmBD,CA/BAO,CADH,EAiCE;IACAP,iBAAiB,GAAG,EAApBA,CAAuB;IAAvBA,CADA,CAGA;IACA;EACD;;EACD,OAAO;IACLO,MAAM,EAANA,MADK;IAELe,MAAM,EAAEtB;EAFH,CAAP;AAID;;AAED,SAASuB,IAAT,CACEC,MADF,EAEEhB,IAFF,EAGc;EACZ,IAAMiB,OAAO,GAA2B,EAAxC;EACA5C,MAAM,CAAC2B,IAAP3B,CAAY2C,MAAZ3C,EAAoB6C,OAApB7C,CAA4B,UAAC8C,GAAD,EAAS;IACnC,IAAI,CAACnB,IAAI,CAACoB,QAALpB,CAAcmB,GAAdnB,CAAL,EAA8B;MAC5BiB,OAAO,CAACE,GAAD,CAAPF,GAAeD,MAAM,CAACG,GAAD,CAArBF;IACD;EACF,CAJD5C;EAKA,OAAO4C,OAAP;AACD;;AAMM,SAASI,WAAT,CACLC,MADK,EAELC,IAFK,EAGLC,SAHK,EAIG;EACR;EACA,IAAIC,IAAJ;EACA,IAAIC,WAAW,GAAG,OAAOH,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCI,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBJ,IAArBI,CAApD,CAHQ,CAKR;EACA;;EACA,IAAMC,aAAa,GAAGF,WAAW,CAACG,KAAZH,CAAiB,oBAAjBA,CAAtB;EACA,IAAMI,kBAAkB,GAAGF,aAAa,GACpCF,WAAW,CAACK,KAAZL,CAAkBE,aAAa,CAAC,CAAD,CAAbA,CAAiBI,MAAnCN,CADoC,GAEpCA,WAFJ;EAIA,IAAMO,QAAQ,GAAGH,kBAAkB,CAACI,KAAnBJ,CAAyB,GAAzBA,CAAjB;;EAEA,IAAI,CAACG,QAAQ,CAAC,CAAD,CAARA,IAAe,EAAhB,EAAoBJ,KAApB,CAAyB,WAAzB,CAAJ,EAA4C;IAC1CM,OAAO,CAACC,KAARD,+CACyCT,WADzCS;IAGA,IAAME,aAAa,GAAGC,CAAAA,GAAAA,MAAAA,EAAwB,wBAAxBA,CAAyBR,kBAAzBQ,CAAtB;IACAZ,WAAW,GAAG,CAACE,aAAa,GAAGA,aAAa,CAAC,CAAD,CAAhB,GAAsB,EAApC,IAA0CS,aAAxDX;EACD,CApBO,CAsBR;;;EACA,IAAI,CAACjD,UAAU,CAACiD,WAAD,CAAf,EAA8B;IAC5B,OAAQF,SAAS,GAAG,CAACE,WAAD,CAAH,GAAmBA,WAApC;EACD;;EAED,IAAI;IACFD,IAAI,GAAG,IAAI1C,GAAJ,CACL2C,WAAW,CAACa,UAAZb,CAAuB,GAAvBA,IAA8BJ,MAAM,CAACkB,MAArCd,GAA8CJ,MAAM,CAACpC,QADhD,EAEL,UAFK,CAAPuC;EAID,CALD,CAKE,OAAOtC,CAAP,EAAU;IACV;IACAsC,IAAI,GAAG,IAAI1C,GAAJ,CAAQ,GAAR,EAAa,UAAb,CAAP0C;EACD;;EACD,IAAI;IACF,IAAMgB,QAAQ,GAAG,IAAI1D,GAAJ,CAAQ2C,WAAR,EAAqBD,IAArB,CAAjB;IACAgB,QAAQ,CAACvD,QAATuD,GAAoBC,CAAAA,GAAAA,uBAAAA,EAA0B,0BAA1BA,CAA2BD,QAAQ,CAACvD,QAApCwD,CAApBD;IACA,IAAIE,cAAc,GAAG,EAArB;;IAEA,IACEC,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAeH,QAAQ,CAACvD,QAAxB0D,KACAH,QAAQ,CAACI,YADTD,IAEApB,SAHF,EAIE;MACA,IAAMjC,KAAK,GAAGuD,CAAAA,GAAAA,YAAAA,EAAsB,sBAAtBA,CAAuBL,QAAQ,CAACI,YAAhCC,CAAd;;MAEA,qBAA2B1D,aAAa,CACtCqD,QAAQ,CAACvD,QAD6B,EAEtCuD,QAAQ,CAACvD,QAF6B,EAGtCK,KAHsC,CAAxC;MAAA,IAAQuB,MAAR,kBAAQA,MAAR;MAAA,IAAgBf,MAAhB,kBAAgBA,MAAhB;;MAMA,IAAIe,MAAJ,EAAY;QACV6B,cAAc,GAAGhB,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;UACpCzC,QAAQ,EAAE4B,MAD0B;UAEpCiC,IAAI,EAAEN,QAAQ,CAACM,IAFqB;UAGpCxD,KAAK,EAAEwB,IAAI,CAACxB,KAAD,EAAQQ,MAAR;QAHyB,CAArB4B,CAAjBgB;MAKD;IACF,CAzBC,CA2BF;;;IACA,IAAMK,YAAY,GAChBP,QAAQ,CAACzD,MAATyD,KAAoBhB,IAAI,CAACzC,MAAzByD,GACIA,QAAQ,CAAClB,IAATkB,CAAcV,KAAdU,CAAoBA,QAAQ,CAACzD,MAATyD,CAAgBT,MAApCS,CADJA,GAEIA,QAAQ,CAAClB,IAHf;IAKA,OACEC,SAAS,GAAG,CAACwB,YAAD,EAAeL,cAAc,IAAIK,YAAjC,CAAH,GAAoDA,YAD/D;EAGD,CApCD,CAoCE,OAAO7D,EAAP,EAAU;IACV,OAAQqC,SAAS,GAAG,CAACE,WAAD,CAAH,GAAmBA,WAApC;EACD;AACF;;AAED,SAASuB,WAAT,CAAqBvE,GAArB,EAAkC;EAChC,IAAMM,MAAM,GAAGH,CAAAA,GAAAA,MAAAA,EAAiB,iBAAjBA,EAAf;EAEA,OAAOH,GAAG,CAAC6D,UAAJ7D,CAAeM,MAAfN,IAAyBA,GAAG,CAACwE,SAAJxE,CAAcM,MAAM,CAACgD,MAArBtD,CAAzBA,GAAwDA,GAA/D;AACD;;AAED,SAASyE,YAAT,CAAsB7B,MAAtB,EAA0C5C,GAA1C,EAAoD0E,EAApD,EAA8D;EAC5D;EACA;EACA,mBAAiC/B,WAAW,CAACC,MAAD,EAAS5C,GAAT,EAAc,IAAd,CAA5C;EAAA;EAAA,IAAKsE,YAAL;EAAA,IAAmBK,UAAnB;;EACA,IAAMrE,MAAM,GAAGH,CAAAA,GAAAA,MAAAA,EAAiB,iBAAjBA,EAAf;EACA,IAAMyE,aAAa,GAAGN,YAAY,CAACT,UAAbS,CAAwBhE,MAAxBgE,CAAtB;EACA,IAAMO,WAAW,GAAGF,UAAU,IAAIA,UAAU,CAACd,UAAXc,CAAsBrE,MAAtBqE,CAAlC;EAEAL,YAAY,GAAGC,WAAW,CAACD,YAAD,CAA1BA;EACAK,UAAU,GAAGA,UAAU,GAAGJ,WAAW,CAACI,UAAD,CAAd,GAA6BA,UAApDA;EAEA,IAAMG,WAAW,GAAGF,aAAa,GAAGN,YAAH,GAAkBS,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYT,YAAZS,CAAnD;EACA,IAAMC,UAAU,GAAGN,EAAE,GACjBH,WAAW,CAAC5B,WAAW,CAACC,MAAD,EAAS8B,EAAT,CAAZ,CADM,GAEjBC,UAAU,IAAIL,YAFlB;EAIA,OAAO;IACLtE,GAAG,EAAE8E,WADA;IAELJ,EAAE,EAAEG,WAAW,GAAGG,UAAH,GAAgBD,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYC,UAAZD;EAF1B,CAAP;AAID;;AAED,SAASE,mBAAT,CAA6BzE,QAA7B,EAA+C0E,KAA/C,EAAgE;EAC9D,IAAMC,aAAa,GAAGC,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBC,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB7E,QAApB6E,CAApBD,CAAtB;;EACA,IAAID,aAAa,KAAK,MAAlBA,IAA4BA,aAAa,KAAK,SAAlD,EAA6D;IAC3D,OAAO3E,QAAP;EACD,CAJ6D,CAM9D;;;EACA,IAAI,CAAC0E,KAAK,CAACxC,QAANwC,CAAeC,aAAfD,CAAL,EAAoC;IAClC;IACAA,KAAK,CAACI,IAANJ,CAAW,UAACK,IAAD,EAAU;MACnB,IAAIrB,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAeqB,IAAfrB,KAAwBlD,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcuE,IAAdvE,EAAoBwE,EAApBxE,CAAuByE,IAAvBzE,CAA4BmE,aAA5BnE,CAA5B,EAAwE;QACtER,QAAQ,GAAG+E,IAAX/E;QACA,OAAO,IAAP;MACD;IACF,CALD0E;EAMD;;EACD,OAAOE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB5E,QAApB4E,CAAP;AACD;;AAuED,IAAMM,uBAAuB,GAC3BC,OAAO,CAACC,GAARD,CAAYE,yBAAZF,IACA,OAAOG,MAAP,KAAkB,WADlBH,IAEA,uBAAuBG,MAAM,CAACC,OAF9BJ,IAGA,CAAC,CAAE,YAAY;EACb,IAAI;IACF,IAAIK,CAAC,GAAG,QAAR,CADE,CAEF;;IACA,OAAOC,cAAc,CAACC,OAAfD,CAAuBD,CAAvBC,EAA0BD,CAA1BC,GAA8BA,cAAc,CAACE,UAAfF,CAA0BD,CAA1BC,CAA9BA,EAA4D,IAAnE;EACD,CAJD,CAIE,OAAOG,CAAP,EAAU,CAAE;AACf,CANE,EAJL;AAYA,IAAMC,kBAAkB,GAAGC,MAAM,CAAC,oBAAD,CAAjC;;AAEA,SAASC,UAAT,CACEvG,GADF,EAEEwG,QAFF,EAGEC,OAHF,EAIqB;EACnB,OAAOC,KAAK,CAAC1G,GAAD,EAAM;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA2G,WAAW,EAAE,aAZG;IAahBC,MAAM,EAAEH,OAAO,CAACG,MAARH,IAAkB,KAbV;IAchBI,OAAO,EAAElH,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkB8G,OAAO,CAACI,OAA1BlH,EAAmC;MAC1C,iBAAiB;IADyB,CAAnCA;EAdO,CAAN,CAAL+G,CAiBJI,IAjBIJ,CAiBC,UAACK,QAAD,EAAc;IACpB,OAAO,CAACA,QAAQ,CAACC,EAAV,IAAgBR,QAAQ,GAAG,CAA3B,IAAgCO,QAAQ,CAACE,MAATF,IAAmB,GAAnD,GACHR,UAAU,CAACvG,GAAD,EAAMwG,QAAQ,GAAG,CAAjB,EAAoBC,OAApB,CADP,GAEHM,QAFJ;EAGD,CArBML,CAAP;AAsBD;;AAED,IAAMQ,eAAe,GAAiC,EAAtD;;AAqBA,SAASC,aAAT,OAUkD;EAAA,IAThDC,QASgD,QAThDA,QASgD;EAAA,IARhDC,aAQgD,QARhDA,aAQgD;EAAA,IAPhDC,UAOgD,QAPhDA,UAOgD;EAAA,IANhDC,aAMgD,QANhDA,aAMgD;EAAA,IALhDC,cAKgD,QALhDA,cAKgD;EAAA,IAJhDC,SAIgD,QAJhDA,SAIgD;EAAA,IAHhDC,YAGgD,QAHhDA,YAGgD;EAAA,IAFhDC,YAEgD,QAFhDA,YAEgD;EAAA,IADhDC,wBACgD,QADhDA,wBACgD;;EAChD,WAA2B,IAAIvH,GAAJ,CAAQ+G,QAAR,EAAkBtB,MAAM,CAACgC,QAAPhC,CAAgBjD,IAAlC,CAA3B;EAAA,IAAcgF,QAAd,QAAQhF,IAAR;;MAIYxB,I;;EAHZ,IAAM0G,OAAO,GAAG,SAAVA,OAAU,CAAC1G,MAAD,EAAqC;IACnDkF,OAAAA,UAAU,CAACa,QAAD,EAAWI,cAAc,GAAG,CAAH,GAAO,CAAhC,EAAmC;MAC3CX,OAAO,EAAES,UAAU,GAAG;QAAEU,OAAO,EAAE;MAAX,CAAH,GAA6B,EADL;MAE3CpB,MAAM,EAAEvF,CAAAA,IAAc,GAAdA,MAAM,IAAA,IAANA,GAAAA,KAAAA,CAAAA,GAAAA,MAAM,CAAEuF,MAARvF,KAAc,IAAdA,GAAAA,IAAAA,GAAkB;IAFiB,CAAnC,CAAVkF,CAIGO,IAJHP,CAIQ,UAACQ,QAAD,EAAc;MAClB,IAAIA,QAAQ,CAACC,EAATD,IAAe1F,CAAAA,MAAM,IAAA,IAANA,GAAAA,KAAAA,CAAAA,GAAAA,MAAM,CAAEuF,MAARvF,MAAmB,MAAtC,EAA8C;QAC5C,OAAO;UAAE+F,QAAQ,EAARA,QAAF;UAAYL,QAAQ,EAARA,QAAZ;UAAsBkB,IAAI,EAAE,EAA5B;UAAgCC,IAAI,EAAE;QAAtC,CAAP;MACD;;MAED,OAAOnB,QAAQ,CAACkB,IAATlB,GAAgBD,IAAhBC,CAAqB,UAACkB,IAAD,EAAU;QACpC,IAAI,CAAClB,QAAQ,CAACC,EAAd,EAAkB;UAChB;;;;;AAKG;UACH,IACEO,aAAa,IACb,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB7E,QAArB,CAA8BqE,QAAQ,CAACE,MAAvC,CAFF,EAGE;YACA,OAAO;cAAEG,QAAQ,EAARA,QAAF;cAAYL,QAAQ,EAARA,QAAZ;cAAsBkB,IAAI,EAAJA,IAAtB;cAA4BC,IAAI,EAAE;YAAlC,CAAP;UACD;;UAED,IAAI,CAACX,aAAD,IAAkBR,QAAQ,CAACE,MAATF,KAAoB,GAA1C,EAA+C;gBACzCoB,G;;YAAJ,IAAIA,CAAAA,GAAsB,GAAtBA,gBAAgB,CAACF,IAAD,CAAhBE,KAAsB,IAAtBA,GAAAA,KAAAA,CAAAA,GAAAA,GAAsB,CAAEC,QAA5B,EAAsC;cACpC,OAAO;gBACLhB,QAAQ,EAARA,QADK;gBAELc,IAAI,EAAE;kBAAEE,QAAQ,EAAE/B;gBAAZ,CAFD;gBAGLU,QAAQ,EAARA,QAHK;gBAILkB,IAAI,EAAJA;cAJK,CAAP;YAMD;UACF;;UAED,IAAMvE,KAAK,GAAG,IAAI7D,KAAJ,+BAAd;UAEA;;;;AAIG;;UACH,IAAI,CAAC2H,cAAL,EAAqB;YACnBa,CAAAA,GAAAA,YAAAA,EAAc,cAAdA,CAAe3E,KAAf2E;UACD;;UAED,MAAM3E,KAAN;QACD;;QAED,OAAO;UACL0D,QAAQ,EAARA,QADK;UAELc,IAAI,EAAET,SAAS,GAAGU,gBAAgB,CAACF,IAAD,CAAnB,GAA4B,IAFtC;UAGLlB,QAAQ,EAARA,QAHK;UAILkB,IAAI,EAAJA;QAJK,CAAP;MAMD,CA9CMlB,CAAP;IA+CD,CAxDHR,EAyDGO,IAzDHP,CAyDQ,UAAC+B,IAAD,EAAU;MACd,IACE,CAACZ,YAAD,IACA/B,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YADzB,IAEA2C,IAAI,CAACvB,QAALuB,CAAczB,OAAdyB,CAAsBE,GAAtBF,CAA0B,oBAA1BA,MAAoD,UAHtD,EAIE;QACA,OAAOjB,aAAa,CAACQ,QAAD,CAApB;MACD;;MACD,OAAOS,IAAP;IACD,CAlEH/B,EAmEGkC,KAnEHlC,CAmES,UAACmC,GAAD,EAAS;MACd,OAAOrB,aAAa,CAACQ,QAAD,CAApB;MACA,MAAMa,GAAN;IACD,CAtEHnC,CAAAA;EAsEI,CAvEN,CAFgD,CA2EhD;EACA;EACA;EACA;;;EACA,IAAIqB,wBAAwB,IAAIF,YAAhC,EAA8C;IAC5C,OAAOK,OAAO,CAAC,EAAD,CAAPA,CAAYjB,IAAZiB,CAAiB,UAACO,IAAD,EAAU;MAChCjB,aAAa,CAACQ,QAAD,CAAbR,GAA0BsB,OAAO,CAACC,OAARD,CAAgBL,IAAhBK,CAA1BtB;MACA,OAAOiB,IAAP;IACD,CAHMP,CAAP;EAID;;EAED,IAAIV,aAAa,CAACQ,QAAD,CAAbR,KAA4BwB,SAAhC,EAA2C;IACzC,OAAOxB,aAAa,CAACQ,QAAD,CAApB;EACD;;EACD,OAAQR,aAAa,CAACQ,QAAD,CAAbR,GAA0BU,OAAO,CACvCJ,YAAY,GAAG;IAAEf,MAAM,EAAE;EAAV,CAAH,GAAwB,EADG,CAAzC;AAGD;;AAED,SAASuB,gBAAT,CAA0BF,IAA1B,EAAwC;EACtC,IAAI;IACF,OAAOa,IAAI,CAACC,KAALD,CAAWb,IAAXa,CAAP;EACD,CAFD,CAEE,OAAOpF,KAAP,EAAc;IACd,OAAO,IAAP;EACD;AACF;;AAMM,SAASsF,SAAT,GAAqB;EAC1B,OAAOC,IAAI,CAACC,MAALD,GAAcE,QAAdF,CAAuB,EAAvBA,EAA2B5F,KAA3B4F,CAAiC,CAAjCA,EAAoC,EAApCA,CAAP;AACD;;AAED,SAASG,oBAAT,QAMG;EAAA,IALDpJ,GAKC,SALDA,GAKC;EAAA,IAJD4C,MAIC,SAJDA,MAIC;;EACD;EACA;EACA,IAAI5C,GAAG,KAAK+E,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYsE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUzG,MAAM,CAACkB,MAAjBuF,EAAyBzG,MAAM,CAAC0G,MAAhCD,CAAZtE,CAAZ,EAAkE;IAChE,MAAM,IAAIlF,KAAJ,iEACqDG,GADrD,cAC4D8H,QAAQ,CAACjF,IADrE,EAAN;EAGD;;EACDiD,MAAM,CAACgC,QAAPhC,CAAgBjD,IAAhBiD,GAAuB9F,GAAvB8F;AACD;;AAED,IAAMyD,mBAAmB,GAAG,SAAtBA,mBAAsB,QAMtB;EAAA,IALJ5I,KAKI,SALJA,KAKI;EAAA,IAJJiC,MAII,SAJJA,MAII;EACJ,IAAI9C,SAAS,GAAG,KAAhB;;EACA,IAAM0J,MAAM,GAAI5G,MAAM,CAAC6G,GAAP7G,GAAa,YAAM;IACjC9C,SAAS,GAAG,IAAZA;EACA,CAFF;;EAIA,IAAM4J,eAAe,GAAG,SAAlBA,eAAkB,GAAM;IAC5B,IAAI5J,SAAJ,EAAe;MACb,IAAM4D,KAAK,GAAQ,IAAI7D,KAAJ,iDACuBc,KADvB,QAAnB;MAGA+C,KAAK,CAAC5D,SAAN4D,GAAkB,IAAlBA;MACA,MAAMA,KAAN;IACD;;IAED,IAAI8F,MAAM,KAAK5G,MAAM,CAAC6G,GAAtB,EAA2B;MACzB7G,MAAM,CAAC6G,GAAP7G,GAAa,IAAbA;IACD;EACF,CAZD;;EAaA,OAAO8G,eAAP;AACD,CA1BD;;IA4BqBC,M;EAyCnBM,gBACEzJ,SADFyJ,EAEEpJ,MAFFoJ,EAGEvF,GAHFuF,SAmCE;IAAA;;IAAA,IA9BEC,YA8BF,SA9BEA,YA8BF;IAAA,IA7BEC,UA6BF,SA7BEA,UA6BF;IAAA,IA5BEC,GA4BF,SA5BEA,GA4BF;IAAA,IA3BEC,OA2BF,SA3BEA,OA2BF;IAAA,IA1BEC,SA0BF,SA1BEA,SA0BF;IAAA,IAzBE5B,GAyBF,SAzBEA,GAyBF;IAAA,IAxBE6B,YAwBF,SAxBEA,YAwBF;IAAA,IAvBEC,UAuBF,SAvBEA,UAuBF;IAAA,IAtBElB,MAsBF,SAtBEA,MAsBF;IAAA,IArBEmB,OAqBF,SArBEA,OAqBF;IAAA,IApBEC,aAoBF,SApBEA,aAoBF;IAAA,IAnBEC,aAmBF,SAnBEA,aAmBF;IAAA,IAlBEC,SAkBF,SAlBEA,SAkBF;IAAA,IAjBEC,KAiBF,SAjBEA,KAiBF;;IAAA;;IArEF;IACAjB,KAAAA,GAAAA,GAAqB,EAArBA;IAgBAC,KAAAA,oBAAAA,GAAuB,IAAvBA;IAaA,KAAQC,IAAR,GAAuBd,SAAS,EAAhC;;IAiKAiE,KAAAA,UAAAA,GAAa,UAACE,CAAD,EAA4B;MACvC,IAAQtD,oBAAR,GAAiC,MAAjC,CAAQA,oBAAR;MACA,MAAI,CAACA,oBAAL,GAA4B,KAA5B;MAEA,IAAM4C,KAAK,GAAGU,CAAC,CAACV,KAAhB;;MAEA,IAAI,CAACA,KAAL,EAAY;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAQjM,SAAR,GAA4B,MAA5B,CAAQA,QAAR;QAAA,IAAkBK,KAAlB,GAA4B,MAA5B,CAAkBA,KAAlB;;QACA,MAAI,CAACkM,WAAL,CACE,cADF,EAEE9J,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;UAAEzC,QAAQ,EAAEuE,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYvE,SAAZuE,CAAZ;UAAmClE,KAAK,EAALA;QAAnC,CAArBoC,CAFF,EAGE0J,CAAAA,GAAAA,MAAAA,EAAM,MAANA,EAHF;;QAKA;MACD,CAvBsC,CAyBvC;;;MACA,IAAIF,KAAK,CAACW,IAAV,EAAgB;QACdtH,MAAM,CAACgC,QAAPhC,CAAgBuH,MAAhBvH;QACA;MACD;;MAED,IAAI,CAAC2G,KAAK,CAACa,GAAX,EAAgB;QACd;MACD,CAjCsC,CAmCvC;;;MACA,IACEzD,oBAAoB,IACpB,MAAI,CAACP,MAAL,KAAgBmD,KAAK,CAAChG,OAANgG,CAAcnD,MAD9BO,IAEA4C,KAAK,CAAC/H,EAAN+H,KAAa,MAAI,CAAC3I,MAHpB,EAIE;QACA;MACD;;MAED,IAAIyJ,YAAJ;MACA,IAAQvN,GAAR,GAAkCyM,KAAlC,CAAQzM,GAAR;MAAA,IAAa0E,EAAb,GAAkC+H,KAAlC,CAAa/H,EAAb;MAAA,IAAiB+B,OAAjB,GAAkCgG,KAAlC,CAAiBhG,OAAjB;MAAA,IAA0BhE,GAA1B,GAAkCgK,KAAlC,CAA0BhK,GAA1B;;MACA,IAAIkD,OAAO,CAACC,GAARD,CAAYE,yBAAhB,EAA2C;QACzC,IAAIH,uBAAJ,EAA6B;UAC3B,IAAI,MAAI,CAACoE,IAAL,KAAcrH,GAAlB,EAAuB;YACrB;YACA,IAAI;cACFwD,cAAc,CAACC,OAAfD,CACE,mBAAmB,MAAI,CAAC6D,IAD1B7D,EAEE6C,IAAI,CAAC0E,SAAL1E,CAAe;gBAAE2E,CAAC,EAAEnC,IAAI,CAACoC,WAAV;gBAAuBC,CAAC,EAAErC,IAAI,CAACsC;cAA/B,CAAf9E,CAFF7C;YAID,CALD,CAKE,OAAA,CAAA,EAAM,CAAE,CAPW,CASrB;;;YACA,IAAI;cACF,IAAMD,CAAC,GAAGC,cAAc,CAAC4H,OAAf5H,CAAuB,mBAAmBxD,GAA1CwD,CAAV;cACAsH,YAAY,GAAGzE,IAAI,CAACC,KAALD,CAAW9C,CAAX8C,CAAfyE;YACD,CAHD,CAGE,OAAA,EAAA,EAAM;cACNA,YAAY,GAAG;gBAAEE,CAAC,EAAE,CAAL;gBAAQE,CAAC,EAAE;cAAX,CAAfJ;YACD;UACF;QACF;MACF;;MACD,MAAI,CAACzD,IAAL,GAAYrH,GAAZ;;MAEA,yBAAqBqL,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiB9N,GAAjB8N,CAArB;MAAA,IAAQtN,QAAR,sBAAQA,QAAR,CArEuC,CAuEvC;MACA;;;MACA,IACE,MAAI,CAACqL,KAAL,IACAnH,EAAE,KAAKK,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAY,MAAI,CAACjB,MAAjBiB,CADP,IAEAvE,QAAQ,KAAKuE,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAY,MAAI,CAACvE,QAAjBuE,CAHf,EAIE;QACA;MACD,CA/EsC,CAiFvC;MACA;;;MACA,IAAI,MAAI,CAACgJ,IAAL,IAAa,CAAC,MAAI,CAACA,IAAL,CAAUtB,KAAV,CAAlB,EAAoC;QAClC;MACD;;MAED,MAAI,CAACuB,MAAL,CACE,cADF,EAEEhO,GAFF,EAGE0E,EAHF,EAIE/E,MAAM,CAACC,MAAPD,CAAwD,EAAxDA,EAA4D8G,OAA5D9G,EAAqE;QACnEsO,OAAO,EAAExH,OAAO,CAACwH,OAARxH,IAAmB,MAAI,CAACyH,QADkC;QAEnE5E,MAAM,EAAE7C,OAAO,CAAC6C,MAAR7C,IAAkB,MAAI,CAACiE,aAFoC;QAGnE;QACAyD,EAAE,EAAE;MAJ+D,CAArExO,CAJF,EAUE4N,YAVF;IAYD,CAnGDN,CA1HE,CACA;;;IACA,IAAMtM,KAAK,GAAGyE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB5E,SAApB4E,CAAd,CAFA,CAIA;;IACA,KAAK0F,UAAL,GAAkB,EAAlB,CALA,CAMA;IACA;IACA;;IACA,IAAItK,SAAQ,KAAK,SAAjB,EAA4B;MAC1B,KAAKsK,UAAL,CAAgBnK,KAAhB,IAAyB;QACvB2J,SAAS,EAATA,SADuB;QAEvBS,OAAO,EAAE,IAFc;QAGvBC,KAAK,EAAEd,YAHgB;QAIvBxB,GAAG,EAAHA,GAJuB;QAKvBuC,OAAO,EAAEf,YAAY,IAAIA,YAAY,CAACe,OALf;QAMvBC,OAAO,EAAEhB,YAAY,IAAIA,YAAY,CAACgB,OANf;QAOvBC,OAAO,EAAE,CAAC,CAACN;MAPY,CAAzB;IASD;;IAED,KAAKC,UAAL,CAAgB,OAAhB,IAA2B;MACzBR,SAAS,EAAEF,GADc;MAEzBgB,WAAW,EAAE;IAFY,CAA3B,CArBA,CA4BA;IACA;;IACA,KAAKrB,MAAL,GAAcJ,MAAM,CAACI,MAArB;IAEA,KAAKI,UAAL,GAAkBA,UAAlB,CAhCA,CAiCA;IACA;;IACA,IAAMkB,iBAAiB,GACrBnH,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAe1D,SAAf0D,KAA4BoH,IAAI,CAACC,aAALD,CAAmBE,UADjD;;IAGA,KAAKC,QAAL,GAAgB9F,OAAO,CAACC,GAARD,CAAY+F,sBAAZ/F,IAAsC,EAAtD;IACA,KAAKgG,GAAL,GAAWpB,YAAX;IACA,KAAKd,GAAL,GAAW,IAAX;IACA,KAAKmC,QAAL,GAAgBvB,OAAhB,CAzCA,CA0CA;IACA;;IACA,KAAKwB,KAAL,GAAa,IAAb;IACA,KAAKC,cAAL,GAAsB,KAAtB;IACA,KAAKC,OAAL,GAAe,CAAC,EACdT,IAAI,CAACC,aAALD,CAAmBU,IAAnBV,IACAA,IAAI,CAACC,aAALD,CAAmBW,GADnBX,IAECA,IAAI,CAACC,aAALD,CAAmBY,MAAnBZ,IAA6B,CAACA,IAAI,CAACC,aAALD,CAAmBa,GAFlDb,IAGC,CAACD,iBAAD,IACC,CAACC,IAAI,CAACxD,QAALwD,CAAcc,MADhB,IAEC,CAACzG,OAAO,CAACC,GAARD,CAAY0G,mBAND,CAAhB;;IASA,IAAI1G,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;MACnC,KAAK7B,OAAL,GAAeA,OAAf;MACA,KAAKC,aAAL,GAAqBA,aAArB;MACA,KAAKC,aAAL,GAAqBA,aAArB;MACA,KAAKmB,cAAL,GAAsB,CAAC,CAACS,CAAAA,GAAAA,mBAAAA,EAAkB,kBAAlBA,CACtB5B,aADsB4B,EAEtBjB,IAAI,CAACxD,QAALwD,CAAckB,QAFQD,CAAxB;IAID;;IAED,KAAKE,KAAL,GAAa;MACX9L,KAAK,EAALA,KADW;MAEXH,QAAQ,EAARA,SAFW;MAGXK,KAAK,EAALA,MAHW;MAIXiD,MAAM,EAAEuH,iBAAiB,GAAG7K,SAAH,GAAckE,GAJ5B;MAKXkG,SAAS,EAAE,CAAC,CAACA,SALF;MAMXtB,MAAM,EAAE3D,OAAO,CAACC,GAARD,CAAY2G,mBAAZ3G,GAAkC2D,MAAlC3D,GAA2CkD,SANxC;MAOX2B,UAAU,EAAVA;IAPW,CAAb;IAUA,KAAKkC,gCAAL,GAAwC/D,OAAO,CAACC,OAARD,CAAgB,KAAhBA,CAAxC;;IAEA,IAAI,OAAO7C,MAAP,KAAkB,WAAtB,EAAmC;MACjC;MACA;MACA,IAAI,CAACpB,GAAE,CAACb,UAAHa,CAAc,IAAdA,CAAL,EAA0B;QACxB;QACA;QACA,IAAM+B,OAAO,GAAsB;UAAE6C,MAAM,EAANA;QAAF,CAAnC;QACA,IAAMxF,MAAM,GAAG6I,CAAAA,GAAAA,MAAAA,EAAM,MAANA,EAAf;QAEA,KAAKD,gCAAL,GAAwCE,iBAAiB,CAAC;UACxDhK,MAAM,EAAE,IADgD;UAExD0G,MAAM,EAANA,MAFwD;UAGxDxF,MAAM,EAANA;QAHwD,CAAD,CAAjB8I,CAIrC9F,IAJqC8F,CAIhC,UAACC,OAAD,EAAa;UAGjBpG,OAAO,CAASqG,kBAAhBrG,GAAqC/B,GAAE,KAAKlE,SAA5CiG;;UAEF,MAAI,CAACsG,WAAL,CACE,cADF,EAEEF,OAAO,GACH/I,MADG,GAEHb,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;YACnBzC,QAAQ,EAAEuE,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYvE,SAAZuE,CADS;YAEnBlE,KAAK,EAALA;UAFmB,CAArBoC,CAJN,EAQEa,MARF,EASE2C,OATF;;UAWA,OAAOoG,OAAP;QACD,CArBuCD,CAAxC;MAsBD;;MAED9G,MAAM,CAACkH,gBAAPlH,CAAwB,UAAxBA,EAAoC,KAAKmH,UAAzCnH,EAjCiC,CAmCjC;MACA;;MACA,IAAIH,OAAO,CAACC,GAARD,CAAYE,yBAAhB,EAA2C;QACzC,IAAIH,uBAAJ,EAA6B;UAC3BI,MAAM,CAACC,OAAPD,CAAeoH,iBAAfpH,GAAmC,QAAnCA;QACD;MACF;IACF;EACF;;;;WAuGDuH,kBAAe;MACbvH,MAAM,CAACgC,QAAPhC,CAAgBuH,MAAhBvH;IACD;IAED;;AAEG;;;;WACHsI,gBAAO;MACLtI,MAAM,CAACC,OAAPD,CAAesI,IAAftI;IACD;IAED;;;;;AAKG;;;;WACHuI,cAAKrO,GAALqO,EAAe3J,EAAf2J,EAA0D;MAAA,IAAjC5H,OAAiC,uEAAJ,EAAI;;MACxD,IAAId,OAAO,CAACC,GAARD,CAAYE,yBAAhB,EAA2C;QACzC;QACA;QACA,IAAIH,uBAAJ,EAA6B;UAC3B,IAAI;YACF;YACAO,cAAc,CAACC,OAAfD,CACE,mBAAmB,KAAK6D,IAD1B7D,EAEE6C,IAAI,CAAC0E,SAAL1E,CAAe;cAAE2E,CAAC,EAAEnC,IAAI,CAACoC,WAAV;cAAuBC,CAAC,EAAErC,IAAI,CAACsC;YAA/B,CAAf9E,CAFF7C;UAID,CAND,CAME,OAAA,CAAA,EAAM,CAAE;QACX;MACF;;MAbuD,oBAcxCxB,YAAY,CAAC,IAAD,EAAOzE,GAAP,EAAY0E,EAAZ,CAd4B;;MAcpD1E,GAdoD,iBAcpDA,GAdoD;MAc/C0E,EAd+C,iBAc/CA,EAd+C;MAexD,OAAO,KAAKsJ,MAAL,CAAY,WAAZ,EAAyBhO,GAAzB,EAA8B0E,EAA9B,EAAkC+B,OAAlC,CAAP;IACD;IAED;;;;;AAKG;;;;WACH1E,iBAAQ/B,GAAR+B,EAAkB2C,EAAlB3C,EAA6D;MAAA,IAAjC0E,OAAiC,uEAAJ,EAAI;;MAAA,qBAC3ChC,YAAY,CAAC,IAAD,EAAOzE,GAAP,EAAY0E,EAAZ,CAD+B;;MACvD1E,GADuD,kBACvDA,GADuD;MAClD0E,EADkD,kBAClDA,EADkD;MAE3D,OAAO,KAAKsJ,MAAL,CAAY,cAAZ,EAA4BhO,GAA5B,EAAiC0E,EAAjC,EAAqC+B,OAArC,CAAP;IACD;;;WAEauH,gBACZpH,MADYoH,EAEZhO,GAFYgO,EAGZtJ,EAHYsJ,EAIZvH,OAJYuH,EAKZT,YALYS,EAK2B;;;aALzC,mBAAA,0CAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,IAOOjO,UAAU,CAACC,GAAD,CAPjB;kBAAA;kBAAA;gBAAA;;gBAQIoJ,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAHA,GAAF;kBAAO4C,MAAM,EAAA;gBAAb,CAAD,CAApBwG;gBARJ,iCASW,KATX;;cAAA;gBAWE;gBACA;gBACA;gBACMkF,eAdR,GAc2B7H,OAAO,CAAS0H,EAd3C;gBAeQI,iBAfR,GAgBID,eAAe,IACd7H,OAAO,CAASqG,kBADjBwB,IAEAE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUxO,GAAVwO,EAAehO,QAAfgO,KAA4BA,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAU9J,EAAV8J,EAAchO,QAlB9C;gBAoBQiO,SApBR,GAoBoB,QAAA,CAAA,EAAA,EACb,KAAA,CAAKhC,KADQ,CApBpB,EAwBE;gBACA;gBACA;;gBACMiC,gBA3BR,GA2B2B,KAAA,CAAK3C,OAAL,KAAiB,IA3B5C;gBA4BE,KAAA,CAAKA,OAAL,GAAe,IAAf;gBACMF,KA7BR,GA6BgB,KAAA,CAAKA,KA7BrB;;gBA+BE,IAAI,CAACyC,eAAL,EAAsB;kBACpB,KAAA,CAAKzC,KAAL,GAAa,KAAb;gBACD,CAjCH,CAmCE;gBACA;;;gBApCF,MAqCMyC,eAAe,IAAI,KAAA,CAAK7E,GArC9B;kBAAA;kBAAA;gBAAA;;gBAAA,iCAsCW,KAtCX;;cAAA;gBAyCQkF,UAzCR,GAyCqBF,SAAS,CAACnF,MAzC/B;;gBAAA,KA2CM3D,OAAO,CAACC,GAARD,CAAY2G,mBA3ClB;kBAAA;kBAAA;gBAAA;;gBA4CImC,SAAS,CAACnF,MAAVmF,GACEhI,OAAO,CAAC6C,MAAR7C,KAAmB,KAAnBA,GACI,KAAA,CAAKiE,aADTjE,GAEIA,OAAO,CAAC6C,MAAR7C,IAAkBgI,SAAS,CAACnF,MAHlCmF;;gBAKA,IAAI,OAAOhI,OAAO,CAAC6C,MAAf,KAA0B,WAA9B,EAA2C;kBACzC7C,OAAO,CAAC6C,MAAR7C,GAAiBgI,SAAS,CAACnF,MAA3B7C;gBACD;;gBAEKmI,QArDV,GAqDqBd,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CACfvN,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYmE,EAAZnE,IAAkBsO,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAenK,EAAfmK,CAAlBtO,GAAuCmE,EADxBoJ,CArDrB;gBAwDUgB,gBAxDV,GAwD6BC,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CACvBH,QAAQ,CAACpO,QADcuO,EAEvB,KAAA,CAAKtE,OAFkBsE,CAxD7B;;gBA6DI,IAAID,gBAAgB,CAACE,cAArB,EAAqC;kBACnCP,SAAS,CAACnF,MAAVmF,GAAmBK,gBAAgB,CAACE,cAApCP;kBACAG,QAAQ,CAACpO,QAAToO,GAAoB7J,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAY6J,QAAQ,CAACpO,QAArBuE,CAApB6J;kBACAlK,EAAE,GAAGzB,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB2L,QAArB3L,CAALyB;kBACA1E,GAAG,GAAG+E,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CACJgK,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CACExO,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYP,GAAZO,IAAmBsO,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAe7O,GAAf6O,CAAnBtO,GAAyCP,GAD3C+O,EAEE,KAAA,CAAKtE,OAFPsE,EAGEvO,QAJEuE,CAAN/E;gBAMD;;gBACGiP,WAxER,GAwEsB,KAxEtB,EA0EI;gBACA;;gBACA,IAAItJ,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;kBACnC;kBACA,IAAI,EAAC,CAAA,GAAY,GAAZ,KAAA,CAAK7B,OAAL,KAAY,IAAZ,GAAA,KAAA,CAAA,GAAA,GAAY,CAAE/H,QAAd,CAAuB+L,SAAS,CAACnF,MAAjC,CAAD,CAAJ,EAAgD;oBAC9CsF,QAAQ,CAACpO,QAAToO,GAAoBvF,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUuF,QAAQ,CAACpO,QAAnB6I,EAA6BoF,SAAS,CAACnF,MAAvCD,CAApBuF;oBACAxF,oBAAoB,CAAC;sBACnBpJ,GAAG,EAAEiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB2L,QAArB3L,CADc;sBAEnBL,MAAM,EAAA;oBAFa,CAAD,CAApBwG,CAF8C,CAM9C;oBACA;;oBACA6F,WAAW,GAAG,IAAdA;kBACD;gBACF;;gBAEKC,cA1FV,GA0F2B3C,CAAAA,GAAAA,mBAAAA,EAAkB,kBAAlBA,CACrB,KAAA,CAAK5B,aADgB4B,EAErB1D,SAFqB0D,EAGrBkC,SAAS,CAACnF,MAHWiD,CA1F3B,EAgGI;gBACA;;gBACA,IAAI5G,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;kBACnC;kBACA;kBACA,IACE,CAAC2C,WAAD,IACAC,cADA,IAEA,KAAA,CAAKpD,cAFL,IAGAR,IAAI,CAACxD,QAALwD,CAAckB,QAAdlB,KAA2B4D,cAAc,CAACC,MAJ5C,EAKE;oBACMC,YADN,GACqBP,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAenK,EAAfmK,CADrB;oBAEAzF,oBAAoB,CAAC;sBACnBpJ,GAAG,gBAASkP,cAAc,CAACG,IAAfH,GAAsB,EAAtBA,GAA2B,GAApC,gBACDA,cAAc,CAACC,MADd,SAEApK,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CACD,UACE0J,SAAS,CAACnF,MAAVmF,KAAqBS,cAAc,CAACxE,aAApC+D,GACI,EADJA,cAEQA,SAAS,CAACnF,MAFlBmF,CADF,SAIGW,YAAY,KAAK,GAAjBA,GAAuB,EAAvBA,GAA4BA,YAJ/B,KAIiD,GALhDrK,CAFA,CADgB;sBAUnBnC,MAAM,EAAA;oBAVa,CAAD,CAApBwG,CAFA,CAcA;oBACA;;oBACA6F,WAAW,GAAG,IAAdA;kBACD;gBACF;;gBA5HL,KA8HQA,WA9HR;kBAAA;kBAAA;gBAAA;;gBAAA,iCA+Ha,IAAItG,OAAJ,CAAY,YAAM,CAAE,CAApB,CA/Hb;;cAAA;gBAmIE;gBACA,IAAI2G,MAAE,CAAA,EAAN,EAAQ;kBACNC,WAAW,CAACC,IAAZD,CAAiB,aAAjBA;gBACD;;gBAtIH,mBAwI6C9I,OAxI7C,CAwIUwH,OAxIV,EAwIUA,OAxIV,iCAwIoB,KAxIpB,uCAwI6CxH,OAxI7C,CAwI2BgJ,MAxI3B,EAwI2BA,MAxI3B,gCAwIoC,IAxIpC;gBAyIQC,UAzIR,GAyIqB;kBAAEzB,OAAO,EAAPA;gBAAF,CAzIrB;;gBA2IE,IAAI,KAAA,CAAK0B,cAAL,IAAuB,KAAA,CAAKlG,GAAhC,EAAqC;kBACnC,IAAI,CAACoC,KAAL,EAAY;oBACVlC,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CACE,kBADFA,EAEEjK,sBAAsB,EAFxBiK,EAGE,KAAA,CAAKgG,cAHPhG,EAIE+F,UAJF/F;kBAMD;;kBACD,KAAA,CAAKF,GAAL;;kBACA,KAAA,CAAKA,GAAL,GAAW,IAAX;gBACD;;gBAED/E,EAAE,GAAGK,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CACHsE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CACE9I,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYmE,EAAZnE,IAAkBsO,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAenK,EAAfmK,CAAlBtO,GAAuCmE,EADzC2E,EAEE5C,OAAO,CAAC6C,MAFVD,EAGE,KAAA,CAAKqB,aAHPrB,CADGtE,CAALL;gBAOMmL,SA/JR,GA+JoBC,CAAAA,GAAAA,aAAAA,EAAY,YAAZA,CAChBvP,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYmE,EAAZnE,IAAkBsO,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAenK,EAAfmK,CAAlBtO,GAAuCmE,EADvBoL,EAEhBrB,SAAS,CAACnF,MAFMwG,CA/JpB;gBAmKE,KAAA,CAAKH,cAAL,GAAsBjL,EAAtB;gBAEMqL,YArKR,GAqKuBpB,UAAU,KAAKF,SAAS,CAACnF,MArKhD,EAuKE;gBACA;;gBAxKF,MA0KM,CAACgF,eAAD,IAAoB,KAAA,CAAK0B,eAAL,CAAqBH,SAArB,CAApB,IAAuD,CAACE,YA1K9D;kBAAA;kBAAA;gBAAA;;gBA2KItB,SAAS,CAAC3K,MAAV2K,GAAmBoB,SAAnBpB;gBACA9E,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,iBAAnBA,EAAsCjF,EAAtCiF,EAA0C+F,UAA1C/F,EA5KJ,CA6KI;;gBACA,KAAA,CAAKoD,WAAL,CAAiBnG,MAAjB,EAAyB5G,GAAzB,EAA8B0E,EAA9B,EAAkC,QAAA,CAAA,EAAA,EAC7B+B,OAD6B,EACtB;kBACVgJ,MAAM,EAAE;gBADE,CADsB,CAAlC;;gBAIA,IAAIA,MAAJ,EAAY;kBACV,KAAA,CAAKQ,YAAL,CAAkBJ,SAAlB;gBACD;;gBApLL;gBAAA;gBAsLM,OAAM,KAAA,CAAKK,GAAL,CAASzB,SAAT,EAAoB,KAAA,CAAK3D,UAAL,CAAgB2D,SAAS,CAAC9N,KAA1B,CAApB,EAAsD,IAAtD,CAAN;;cAtLN;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAwLM,IAAIwP,CAAAA,GAAAA,QAAAA,EAAO,OAAPA,iBAAgBzH,YAAI5I,SAAxB,EAAmC;kBACjC6J,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,kBAAnBA,eAA4CkG,SAA5ClG,EAAuD+F,UAAvD/F;gBACD;;gBA1LP;;cAAA;gBA8LIA,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,oBAAnBA,EAAyCjF,EAAzCiF,EAA6C+F,UAA7C/F;gBA9LJ,iCA+LW,IA/LX;;cAAA;gBAkMMyG,MAlMN,GAkMetC,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiB9N,GAAjB8N,CAlMf;gBAmMQtN,QAnMR,GAmM4B4P,MAnM5B,CAmMQ5P,QAnMR,EAmMkBK,KAnMlB,GAmM4BuP,MAnM5B,CAmMkBvP,KAnMlB,EAqME;gBACA;gBACA;;gBAvMF;gBAAA;gBA0MyC,OAAM8H,OAAO,CAAC4H,GAAR5H,CAAY,CACrD,KAAA,CAAKwB,UAAL,CAAgBqG,WAAhB,EADqD,EAErDC,CAAAA,GAAAA,YAAAA,EAAsB,sBAAtBA,EAFqD,EAGrD,KAAA,CAAKtG,UAAL,CAAgBuG,aAAhB,EAHqD,CAAZ/H,CAAN;;cA1MzC;gBAAA;gBAAA;gBA0MMzD,KA1MN;gBA0M2BoL,QA1M3B,0BA0MeD,UA1Mf;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAgNI;gBACA;gBACAjH,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAE0E,EAAP;kBAAW9B,MAAM,EAAA;gBAAjB,CAAD,CAApBwG;gBAlNJ,iCAmNW,KAnNX;;cAAA;gBAsNE;gBACA;gBACA;gBACA;gBACA;gBACA,IAAI,CAAC,KAAA,CAAKuH,QAAL,CAAcd,SAAd,CAAD,IAA6B,CAACE,YAAlC,EAAgD;kBAC9CnJ,MAAM,GAAG,cAATA;gBACD,CA7NH,CA+NE;gBACA;;;gBACIjC,UAjON,GAiOmBD,EAjOnB,EAmOE;gBACA;gBACA;;gBACAlE,QAAQ,GAAGA,QAAQ,GACf4E,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoByJ,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAerO,QAAfqO,CAApBzJ,CADe,GAEf5E,QAFJA,CAtOF,CA0OE;gBACA;;gBA3OF;gBA4O4B,OAAMoM,iBAAiB,CAAC;kBAChD9I,MAAM,EAAEY,EADwC;kBAEhD4E,MAAM,EAAEmF,SAAS,CAACnF,MAF8B;kBAGhD1G,MAAM,EAAA;gBAH0C,CAAD,CAAvB;;cA5O5B;gBA4OQgO,iBA5OR;;gBAkPE,IAAInK,OAAO,CAACwH,OAARxH,IAAmBmK,iBAAvB,EAA0C;kBACxCpQ,QAAQ,GAAG,KAAA,CAAKA,QAAhBA;gBACD;;gBApPH,MAsPM+N,iBAAiB,IAAI/N,QAAQ,KAAK,SAtPxC;kBAAA;kBAAA;gBAAA;;gBAuPMiG,OAAO,CAASqG,kBAAhBrG,GAAqC,IAArCA;;gBAvPN,MAyPQd,OAAO,CAACC,GAARD,CAAY0G,mBAAZ1G,IAAmCjB,EAAE,CAACb,UAAHa,CAAc,GAAdA,CAzP3C;kBAAA;kBAAA;gBAAA;;gBA0PYmM,cA1PZ,GA0P6BC,CAAAA,GAAAA,gBAAAA,EAAe,OAAfA,CACrB/L,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYsE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUwG,SAAVxG,EAAqBoF,SAAS,CAACnF,MAA/BD,CAAZtE,EAAoD,IAApDA,CADqB+L,EAErB5L,KAFqB4L,EAGrBR,QAHqBQ,EAIrBjQ,KAJqBiQ,EAKrB,UAACC,CAAD;kBAAA,OAAe9L,mBAAmB,CAAC8L,CAAD,EAAI7L,KAAJ,CAAlC;gBAAA,CALqB4L,EAMrB,KAAA,CAAKrG,OANgBqG,CA1P7B;;gBAAA,KAmQUD,cAAc,CAACG,YAnQzB;kBAAA;kBAAA;gBAAA;;gBAoQQ5H,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAE0E,EAAP;kBAAW9B,MAAM,EAAA;gBAAjB,CAAD,CAApBwG;gBApQR,iCAqQe,IArQf;;cAAA;gBAuQM,IAAI,CAACwH,iBAAL,EAAwB;kBACtBjM,UAAU,GAAGkM,cAAc,CAAC/M,MAA5Ba;gBACD;;gBAED,IAAIkM,cAAc,CAACI,WAAfJ,IAA8BA,cAAc,CAACvM,YAAjD,EAA+D;kBAC7D;kBACA;kBACA9D,QAAQ,GAAGqQ,cAAc,CAACvM,YAA1B9D;kBACA4P,MAAM,CAAC5P,QAAP4P,GAAkBrL,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYvE,QAAZuE,CAAlBqL;;kBAEA,IAAI,CAACQ,iBAAL,EAAwB;oBACtB5Q,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;kBACD;gBACF;;gBApRP;gBAAA;;cAAA;gBAsRMoQ,MAAM,CAAC5P,QAAP4P,GAAkBnL,mBAAmB,CAACzE,QAAD,EAAW0E,KAAX,CAArCkL;;gBAEA,IAAIA,MAAM,CAAC5P,QAAP4P,KAAoB5P,QAAxB,EAAkC;kBAChCA,QAAQ,GAAG4P,MAAM,CAAC5P,QAAlBA;kBACA4P,MAAM,CAAC5P,QAAP4P,GAAkBrL,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYvE,QAAZuE,CAAlBqL;;kBAEA,IAAI,CAACQ,iBAAL,EAAwB;oBACtB5Q,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;kBACD;gBACF;;cA/RP;gBAAA,IAmSOD,UAAU,CAAC2E,EAAD,CAnSjB;kBAAA;kBAAA;gBAAA;;gBAAA,MAoSQiB,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YApSjC;kBAAA;kBAAA;gBAAA;;gBAAA,MAqSY,IAAI9F,KAAJ,CACJ,0BAAkBG,GAAlB,0BAAmC0E,EAAnC,sIADI,CArSZ;;cAAA;gBA0SI0E,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAE0E,EAAP;kBAAW9B,MAAM,EAAA;gBAAjB,CAAD,CAApBwG;gBA1SJ,iCA2SW,KA3SX;;cAAA;gBA8SEzE,UAAU,GAAGmL,CAAAA,GAAAA,aAAAA,EAAY,YAAZA,CAAajB,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAelK,UAAfkK,CAAbiB,EAAyCrB,SAAS,CAACnF,MAAnDwG,CAAbnL;gBAEIhE,KAhTN,GAgTcyE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB5E,QAApB4E,CAhTd;gBAiTM8L,UAjTN,GAiTuE,KAjTvE;;gBAAA,KAmTMhN,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAevD,KAAfuD,CAnTN;kBAAA;kBAAA;gBAAA;;gBAoTU0K,QApTV,GAoTqBd,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiBnJ,UAAjBmJ,CApTrB;gBAqTUlN,UArTV,GAqTuBgO,QAAQ,CAACpO,QArThC;gBAuTU2Q,UAvTV,GAuTuBnQ,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcL,KAAdK,CAvTvB;gBAwTIkQ,UAAU,GAAG9P,CAAAA,GAAAA,aAAAA,EAAe,eAAfA,CAAgB+P,UAAhB/P,EAA4BR,UAA5BQ,CAAb8P;gBACME,iBAzTV,GAyT8BzQ,KAAK,KAAKC,UAzTxC;gBA0TUqD,cA1TV,GA0T2BmN,iBAAiB,GACpC1Q,aAAa,CAACC,KAAD,EAAQC,UAAR,EAAoBC,KAApB,CADuB,GAEnC,EA5TT;;gBAAA,MA8TQ,CAACqQ,UAAD,IAAgBE,iBAAiB,IAAI,CAACnN,cAAc,CAAC7B,MA9T7D;kBAAA;kBAAA;gBAAA;;gBA+TYiP,aA/TZ,GA+T4B1R,MAAM,CAAC2B,IAAP3B,CAAYwR,UAAU,CAACjQ,MAAvBvB,EAA+B2R,MAA/B3R,CACpB,UAAC6B,KAAD;kBAAA,OAAW,CAACX,KAAK,CAACW,KAAD,CAAjB;gBAAA,CADoB7B,CA/T5B;;gBAAA,MAmUU0R,aAAa,CAAC/N,MAAd+N,GAAuB,CAAvBA,IAA4B,CAACT,iBAnUvC;kBAAA;kBAAA;gBAAA;;gBAoUQ,IAAIjL,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YAA7B,EAA2C;kBACzClC,OAAO,CAAC8N,IAAR9N,CACE,UACE2N,iBAAiB,uDADnB,0DAKiBC,aAAa,CAAClP,IAAdkP,CACb,IADaA,CALjB,6BADF5N;gBAUD;;gBA/UT,MAiVc,IAAI5D,KAAJ,CACJ,CAACuR,iBAAiB,kCACYpR,GADZ,8CACmDqR,aAAa,CAAClP,IAAdkP,CAC/D,IAD+DA,CADnD,0EAIgBzQ,UAJhB,sDAIwED,KAJxE,QAAlB,0DAMIyQ,iBAAiB,GACb,2BADa,GAEb,sBARR,CADI,CAjVd;;cAAA;gBAAA;gBAAA;;cAAA;gBA8VW,IAAIA,iBAAJ,EAAuB;kBAC5B1M,EAAE,GAAGzB,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CACHtD,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkBiP,QAAlBjP,EAA4B;oBAC1Ba,QAAQ,EAAEyD,cAAc,CAAC7B,MADC;oBAE1BvB,KAAK,EAAEwB,IAAI,CAACxB,KAAD,EAAQoD,cAAc,CAAC5C,MAAvB;kBAFe,CAA5B1B,CADGsD,CAALyB;gBAMD,CAPM,MAOA;kBACL;kBACA/E,MAAM,CAACC,MAAPD,CAAckB,KAAdlB,EAAqBuR,UAArBvR;gBACD;;cAxWL;gBA2WE,IAAI,CAAC2O,eAAL,EAAsB;kBACpB3E,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,kBAAnBA,EAAuCjF,EAAvCiF,EAA2C+F,UAA3C/F;gBACD;;gBA7WH;gBAAA;gBAgXoB,OAAM,KAAA,CAAK8H,YAAL,CAAkB;kBACtC9Q,KAAK,EAALA,KADsC;kBAEtCH,QAAQ,EAARA,QAFsC;kBAGtCK,KAAK,EAALA,KAHsC;kBAItC6D,EAAE,EAAFA,EAJsC;kBAKtCC,UAAU,EAAVA,UALsC;kBAMtC+K,UAAU,EAAVA,UANsC;kBAOtCpG,MAAM,EAAEmF,SAAS,CAACnF,MAPoB;kBAQtCsB,SAAS,EAAE6D,SAAS,CAAC7D,SARiB;kBAStCrD,aAAa,EAAEqJ;gBATuB,CAAlB,CAAN;;cAhXpB;gBAgXQY,SAhXR;;gBA4XI,IAAI,WAAWA,SAAX,IAAwBZ,iBAA5B,EAA+C;kBAC7CpQ,QAAQ,GAAGgR,SAAS,CAAC7Q,KAAV6Q,IAAmB7Q,KAA9BH;kBACAG,KAAK,GAAGH,QAARG;;kBAEA,IAAI,CAAC+O,UAAU,CAACzB,OAAhB,EAAyB;oBACvBpN,KAAK,GAAGlB,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkB6R,SAAS,CAAC3Q,KAAV2Q,IAAmB,EAArC7R,EAAyCkB,KAAzClB,CAARkB;kBACD;;kBAED,IAAIqQ,UAAU,IAAI1Q,QAAQ,KAAK4P,MAAM,CAAC5P,QAAtC,EAAgD;oBAC9Cb,MAAM,CAAC2B,IAAP3B,CAAYuR,UAAZvR,EAAwB6C,OAAxB7C,CAAgC,UAAC8C,GAAD,EAAS;sBACvC,IAAIyO,UAAU,IAAIrQ,KAAK,CAAC4B,GAAD,CAAL5B,KAAeqQ,UAAU,CAACzO,GAAD,CAA3C,EAAkD;wBAChD,OAAO5B,KAAK,CAAC4B,GAAD,CAAZ;sBACD;oBACF,CAJD9C;kBAKD;;kBAED,IAAIuE,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAe1D,QAAf0D,CAAJ,EAA8B;oBACtBwN,UADsB,GAE1B,CAAChC,UAAU,CAACzB,OAAZ,IAAuBuD,SAAS,CAAC7M,UAAjC,GACI6M,SAAS,CAAC7M,UADd,GAEII,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CACEsE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CACE,IAAIhJ,GAAJ,CAAQqE,EAAR,EAAYoD,QAAQ,CAACjF,IAArB,EAA2BrC,QAD7B6I,EAEEoF,SAAS,CAACnF,MAFZD,CADFtE,EAKE,IALFA,CAJsB;oBAYxB4M,SAZwB,GAYZD,UAZY;;oBAc5B,IAAInR,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYoR,SAAZpR,CAAJ,EAA4B;sBAC1BoR,SAAS,GAAG9C,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAe8C,SAAf9C,CAAZ8C;oBACD;;oBAED,IAAIhM,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;sBAC7BsF,YAD6B,GACd7C,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB4C,SAApB5C,EAA+B,KAAA,CAAKtE,OAApCsE,CADc;sBAEnCN,SAAS,CAACnF,MAAVmF,GAAmBmD,YAAY,CAAC5C,cAAb4C,IAA+BnD,SAAS,CAACnF,MAA5DmF;sBACAkD,SAAS,GAAGC,YAAY,CAACpR,QAAzBmR;oBACD;;oBACKR,YAvBsB,GAuBTnQ,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcR,QAAdQ,CAvBS;oBAwBtB6Q,aAxBsB,GAwBNzQ,CAAAA,GAAAA,aAAAA,EAAe,eAAfA,CAAgB+P,YAAhB/P,EAA4BuQ,SAA5BvQ,CAxBM;;oBA0B5B,IAAIyQ,aAAJ,EAAmB;sBACjBlS,MAAM,CAACC,MAAPD,CAAckB,KAAdlB,EAAqBkS,aAArBlS;oBACD;kBACF;gBACF,CA1aL,CA4aI;;;gBA5aJ,MA6aQ,UAAU6R,SA7alB;kBAAA;kBAAA;gBAAA;;gBAAA,MA8aUA,SAAS,CAACM,IAAVN,KAAmB,mBA9a7B;kBAAA;kBAAA;gBAAA;;gBAAA,iCA+ae,KAAA,CAAKxD,MAAL,CAAYpH,MAAZ,EAAoB4K,SAAS,CAACO,MAA9B,EAAsCP,SAAS,CAACQ,KAAhD,EAAuDvL,OAAvD,CA/af;;cAAA;gBAibQ2C,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAEwR,SAAS,CAACS,WAAjB;kBAA8BrP,MAAM,EAAA;gBAApC,CAAD,CAApBwG;gBAjbR,iCAkbe,IAAIT,OAAJ,CAAY,YAAM,CAAE,CAApB,CAlbf;;cAAA;gBAAA,aAsb6C6I,SAtb7C,EAsbU9N,KAtbV,cAsbUA,KAtbV,EAsbiBsH,KAtbjB,cAsbiBA,KAtbjB,EAsbwBC,OAtbxB,cAsbwBA,OAtbxB,EAsbiCC,OAtbjC,cAsbiCA,OAtbjC;gBAwbUgH,SAxbV,GAwb2BV,SAAS,CAAClH,SAxbrC;;gBAybI,IAAI4H,SAAS,IAAIA,SAAS,CAACC,qBAA3B,EAAkD;kBAC1CC,OAD0C,GAChC,GAAGC,MAAH,CAAUH,SAAS,CAACC,qBAAVD,EAAV,CADgC;kBAGhDE,OAAO,CAAC5P,OAAR4P,CAAgB,UAACE,MAAD,EAAiB;oBAC/BC,CAAAA,GAAAA,OAAAA,EAAsB,sBAAtBA,CAAuBD,MAAM,CAACtH,KAA9BuH;kBACD,CAFDH;gBAGD,CA/bL,CAicI;;;gBAjcJ,MAkcQ,CAACnH,OAAO,IAAIC,OAAZ,KAAwBF,KAlchC;kBAAA;kBAAA;gBAAA;;gBAAA,MAmcUA,KAAK,CAACwH,SAANxH,IAAmBA,KAAK,CAACwH,SAANxH,CAAgByH,YAnc7C;kBAAA;kBAAA;gBAAA;;gBAocQ;gBACAhM,OAAO,CAAC6C,MAAR7C,GAAiB,KAAjBA;gBAEMwL,WAvcd,GAuc4BjH,KAAK,CAACwH,SAANxH,CAAgByH,YAvc5C,EAycQ;gBACA;gBACA;;gBA3cR,MA6cUR,WAAW,CAACpO,UAAZoO,CAAuB,GAAvBA,KACAjH,KAAK,CAACwH,SAANxH,CAAgB0H,sBAAhB1H,KAA2C,KA9crD;kBAAA;kBAAA;gBAAA;;gBAgdgB2H,UAhdhB,GAgd6B7E,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiBmE,WAAjBnE,CAhd7B;gBAidU6E,UAAU,CAACnS,QAAXmS,GAAsB1N,mBAAmB,CACvC0N,UAAU,CAACnS,QAD4B,EAEvC0E,KAFuC,CAAzCyN;gBAjdV,iBAsd6ClO,YAAY,CAAA,KAAA,EAE7CwN,WAF6C,EAG7CA,WAH6C,CAtdzD,EAsduBF,MAtdvB,kBAsdkB/R,GAtdlB,EAsdmCgS,KAtdnC,kBAsd+BtN,EAtd/B;gBAAA,iCA2diB,KAAA,CAAKsJ,MAAL,CAAYpH,MAAZ,EAAoBmL,MAApB,EAA4BC,KAA5B,EAAmCvL,OAAnC,CA3djB;;cAAA;gBA6dQ2C,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAEiS,WAAP;kBAAoBrP,MAAM,EAAA;gBAA1B,CAAD,CAApBwG;gBA7dR,iCA8de,IAAIT,OAAJ,CAAY,YAAM,CAAE,CAApB,CA9df;;cAAA;gBAieM8F,SAAS,CAAC7D,SAAV6D,GAAsB,CAAC,CAACzD,KAAK,CAAC4H,WAA9BnE,CAjeN,CAmeM;;gBAneN,MAoeUzD,KAAK,CAAC5C,QAAN4C,KAAmB3E,kBApe7B;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;gBAweU,OAAM,KAAA,CAAKwM,cAAL,CAAoB,MAApB,CAAN;;cAxeV;gBAyeUC,aAAa,GAAG,MAAhBA;gBAzeV;gBAAA;;cAAA;gBAAA;gBAAA;gBA2eUA,aAAa,GAAG,SAAhBA;;cA3eV;gBAAA;gBA8eoB,OAAM,KAAA,CAAKrB,YAAL,CAAkB;kBAClC9Q,KAAK,EAAEmS,aAD2B;kBAElCtS,QAAQ,EAAEsS,aAFwB;kBAGlCjS,KAAK,EAALA,KAHkC;kBAIlC6D,EAAE,EAAFA,EAJkC;kBAKlCC,UAAU,EAAVA,UALkC;kBAMlC+K,UAAU,EAAE;oBAAEzB,OAAO,EAAE;kBAAX,CANsB;kBAOlC3E,MAAM,EAAEmF,SAAS,CAACnF,MAPgB;kBAQlCsB,SAAS,EAAE6D,SAAS,CAAC7D;gBARa,CAAlB,CAAN;;cA9epB;gBA8eQ4G,SA9eR;;gBAAA,MAyfY,UAAUA,SAzftB;kBAAA;kBAAA;gBAAA;;gBAAA,MA0fgB,IAAI3R,KAAJ,wCA1fhB;;cAAA;gBA+fI8J,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,qBAAnBA,EAA0CjF,EAA1CiF,EAA8C+F,UAA9C/F;;gBACA,KAAA,CAAKoD,WAAL,CAAiBnG,MAAjB,EAAyB5G,GAAzB,EAA8B0E,EAA9B,EAAkC+B,OAAlC;;gBAEA,IACE6H,eAAe,IACf9N,QAAQ,KAAK,SADb8N,IAEAhD,CAAAA,CAAAA,IAAwB,GAAxBA,IAAI,CAACC,aAALD,CAAmBN,KAAnBM,KAAwB,IAAxBA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,IAAAA,GAAAA,IAAwB,CAAEkH,SAA1BlH,KAAmC,IAAnCA,GAAAA,KAAAA,CAAAA,GAAmC,IAAA,CAAA,UAAnCA,MAAoD,GAFpDgD,KAGAtD,KAAK,IAAA,IAALA,GAAAA,KAAAA,CAAAA,GAAAA,KAAK,CAAEwH,SAHPlE,CADF,EAKE;kBACA;kBACA;kBACAtD,KAAK,CAACwH,SAANxH,CAAgB+H,UAAhB/H,GAA6B,GAA7BA;gBACD;;gBAED;gBACMgI,mBA9gBV,GA+gBMvM,OAAO,CAACwH,OAARxH,IAAmBgI,SAAS,CAAC9N,KAAV8N,MAAqB+C,CAAAA,MAAe,GAAfA,SAAS,CAAC7Q,KAAV6Q,KAAe,IAAfA,GAAAA,MAAAA,GAAmB7Q,KAAxC8N,CA/gBzB;gBAihBUwE,YAjhBV,GAkhBMxM,CAAAA,OAAc,GAAdA,OAAO,CAACgJ,MAARhJ,KAAc,IAAdA,GAAAA,OAAAA,GAAmB,CAAEA,OAAO,CAAS0H,EAAlB,IAAwB,CAAC6E,mBAlhBlD;gBAmhBUE,WAnhBV,GAmhBwBD,YAAY,GAAG;kBAAExF,CAAC,EAAE,CAAL;kBAAQE,CAAC,EAAE;gBAAX,CAAH,GAAoB,IAnhBxD,EAqhBI;;gBACMwF,mBAthBV,GAshBgC,QAAA,CAAA,EAAA,EACvB1E,SADuB,EACd;kBACZ9N,KAAK,EAALA,KADY;kBAEZH,QAAQ,EAARA,QAFY;kBAGZK,KAAK,EAALA,KAHY;kBAIZiD,MAAM,EAAE+L,SAJI;kBAKZrF,UAAU,EAAE;gBALA,CADc,CAthBhC;gBA8hBU4I,mBA9hBV,GA8hBgC7F,YAAY,IAAA,IAAZA,GAAAA,YAAAA,GAAgB2F,WA9hBhD,EAgiBI;gBACA;gBACA;;gBACMG,eAniBV,GAoiBO5M,OAAO,CAAS0H,EAAhB1H,IACD,CAAC2M,mBADA3M,IAED,CAACiI,gBAFAjI,IAGD,CAACsJ,YAHAtJ,IAID6M,CAAAA,GAAAA,cAAAA,EAAmB,mBAAnBA,CAAoBH,mBAApBG,EAAyC,KAAA,CAAK7G,KAA9C6G,CAxiBN;;gBAAA,IA0iBSD,eA1iBT;kBAAA;kBAAA;gBAAA;;gBAAA;gBA2iBM,OAAM,KAAA,CAAKnD,GAAL,CACJiD,mBADI,EAEJ3B,SAFI,EAGJ4B,mBAHI,EAIJ3K,KAJI,CAIE,UAAC0E,CAAD,EAAO;kBACb,IAAIA,CAAC,CAACrN,SAAN,EAAiB4D,KAAK,GAAGA,KAAK,IAAIyJ,CAAjBzJ,CAAjB,KACK,MAAMyJ,CAAN;gBACN,CAPK,CAAN;;cA3iBN;gBAAA,KAojBUzJ,KApjBV;kBAAA;kBAAA;gBAAA;;gBAqjBQ,IAAI,CAAC4K,eAAL,EAAsB;kBACpB3E,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,kBAAnBA,EAAuCjG,KAAvCiG,EAA8CkG,SAA9ClG,EAAyD+F,UAAzD/F;gBACD;;gBAvjBT,MAwjBcjG,KAxjBd;;cAAA;gBA2jBM,IAAIiC,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;kBACnC,IAAImC,SAAS,CAACnF,MAAd,EAAsB;oBACpBiK,QAAQ,CAACC,eAATD,CAAyBE,IAAzBF,GAAgC9E,SAAS,CAACnF,MAA1CiK;kBACD;gBACF;;gBAED,IAAI,CAACjF,eAAL,EAAsB;kBACpB3E,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,qBAAnBA,EAA0CjF,EAA1CiF,EAA8C+F,UAA9C/F;gBACD,CAnkBP,CAqkBM;;;gBACM+J,SAtkBZ,GAskBqB,MAtkBrB;;gBAukBM,IAAIT,YAAY,IAAIS,SAAS,CAACjO,IAAViO,CAAehP,EAAfgP,CAApB,EAAwC;kBACtC,KAAA,CAAKzD,YAAL,CAAkBvL,EAAlB;gBACD;;cAzkBP;gBAAA,iCA4kBW,IA5kBX;;cAAA;gBAAA;gBAAA;;gBAAA,MA8kBQyL,CAAAA,GAAAA,QAAAA,EAAO,OAAPA,iBAAgBzH,YAAI5I,SA9kB5B;kBAAA;kBAAA;gBAAA;;gBAAA,iCA+kBa,KA/kBb;;cAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAA,EAAA,E;IAmlBC;;;WAEDiN,qBACEnG,MADFmG,EAEE/M,GAFF+M,EAGErI,EAHFqI,EAKQ;MAAA,IADNtG,OACM,uEADuB,EACvB;;MACN,IAAId,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YAA7B,EAA2C;QACzC,IAAI,OAAOG,MAAM,CAACC,OAAd,KAA0B,WAA9B,EAA2C;UACzCtC,OAAO,CAACC,KAARD;UACA;QACD;;QAED,IAAI,OAAOqC,MAAM,CAACC,OAAPD,CAAec,MAAfd,CAAP,KAAkC,WAAtC,EAAmD;UACjDrC,OAAO,CAACC,KAARD,mCAAyCmD,MAAzCnD;UACA;QACD;MACF;;MAED,IAAImD,MAAM,KAAK,WAAXA,IAA0B+F,CAAAA,GAAAA,MAAAA,EAAM,MAANA,OAAajI,EAA3C,EAA+C;QAC7C,KAAKwJ,QAAL,GAAgBzH,OAAO,CAACwH,OAAxB;QACAnI,MAAM,CAACC,OAAPD,CAAec,MAAfd,EACE;UACE9F,GAAG,EAAHA,GADF;UAEE0E,EAAE,EAAFA,EAFF;UAGE+B,OAAO,EAAPA,OAHF;UAIE6G,GAAG,EAAE,IAJP;UAKE7K,GAAG,EAAG,KAAKqH,IAAL,GAAYlD,MAAM,KAAK,WAAXA,GAAyB,KAAKkD,IAA9BlD,GAAqCoC,SAAS;QALlE,CADFlD,EAQE;QACA;QACA;QACA,EAXFA,EAYEpB,EAZFoB;MAcD;IACF;;;WAEK6N,8BACJjL,GADIiL,EAEJnT,QAFImT,EAGJ9S,KAHI8S,EAIJjP,EAJIiP,EAKJjE,UALIiE,EAMJC,aANID,EAMmB;;;aANzB,mBAAA,0CAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAQElQ,OAAO,CAACC,KAARD,CAAciF,GAAdjF;;gBARF,KAUMiF,GAAG,CAAC5I,SAVV;kBAAA;kBAAA;gBAAA;;gBAAA,MAYU4I,GAZV;;cAAA;gBAAA,MAeMmL,CAAAA,GAAAA,YAAAA,EAAY,YAAZA,CAAanL,GAAbmL,KAAqBD,aAf3B;kBAAA;kBAAA;gBAAA;;gBAgBIjK,MAAM,CAACI,MAAPJ,CAAciG,IAAdjG,CAAmB,kBAAnBA,EAAuCjB,GAAvCiB,EAA4CjF,EAA5CiF,EAAgD+F,UAAhD/F,EAhBJ,CAkBI;gBACA;gBACA;gBACA;gBAEA;;gBACAP,oBAAoB,CAAC;kBACnBpJ,GAAG,EAAE0E,EADc;kBAEnB9B,MAAM,EAAA;gBAFa,CAAD,CAApBwG,CAxBJ,CA6BI;gBACA;;gBA9BJ,MA+BU1J,sBAAsB,EA/BhC;;cAAA;gBAAA;gBAAA;gBAoC6C,OAAM,KAAA,CAAKmT,cAAL,CAC7C,SAD6C,CAAN;;cApC7C;gBAAA;gBAoCkBvI,SApClB,yBAoCY/E,IApCZ;gBAoC6B6F,WApC7B,yBAoC6BA,WApC7B;gBAwCUoG,SAxCV,GAwCgD;kBAC1CxG,KAAK,EAALA,KAD0C;kBAE1CV,SAAS,EAATA,SAF0C;kBAG1Cc,WAAW,EAAXA,WAH0C;kBAI1C1C,GAAG,EAAHA,GAJ0C;kBAK1ChF,KAAK,EAAEgF;gBALmC,CAxChD;;gBAAA,IAgDS8I,SAAS,CAACxG,KAhDnB;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;gBAkD0B,OAAM,KAAA,CAAK8I,eAAL,CAAqBxJ,SAArB,EAAgC;kBACtD5B,GAAG,EAAHA,GADsD;kBAEtDlI,QAAQ,EAARA,QAFsD;kBAGtDK,KAAK,EAALA;gBAHsD,CAAhC,CAAN;;cAlD1B;gBAkDQ2Q,SAAS,CAACxG,KAlDlB;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAwDQvH,OAAO,CAACC,KAARD,CAAc,yCAAdA;gBACA+N,SAAS,CAACxG,KAAVwG,GAAkB,EAAlBA;;cAzDR;gBAAA,kCA6DWA,SA7DX;;cAAA;gBAAA;gBAAA;gBAAA,kCA+DW,KAAA,CAAKmC,oBAAL,CACLxD,CAAAA,GAAAA,QAAAA,EAAO,OAAPA,gCAAuC,IAAItQ,KAAJ,CAAUkU,eAAe,EAAzB,CADlC,EAELvT,QAFK,EAGLK,KAHK,EAIL6D,EAJK,EAKLgL,UALK,EAML,IANK,CA/DX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAA,EAAA,E;IAwEC;;;WAEK+B,6BAsBL;MAAA,IArBQuC,cAqBR,SArBCrT,KAqBD;MAAA,IApBCH,QAoBD,SApBCA,QAoBD;MAAA,IAnBCK,KAmBD,SAnBCA,KAmBD;MAAA,IAlBC6D,EAkBD,SAlBCA,EAkBD;MAAA,IAjBCC,UAiBD,SAjBCA,UAiBD;MAAA,IAhBC+K,UAgBD,SAhBCA,UAgBD;MAAA,IAfCpG,MAeD,SAfCA,MAeD;MAAA,IAdC/B,aAcD,SAdCA,aAcD;MAAA,IAbCqD,SAaD,SAbCA,SAaD;MAAA,IAZChD,wBAYD,SAZCA,wBAYD;;;;aAtBD,mBAAA,0CAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAuBE;;;;;AAKG;gBACCjH,KA7BN,GA6BcqT,cA7Bd;gBAAA;gBAgCUtK,eAhCV,GAgC4BH,mBAAmB,CAAC;kBAAE5I,KAAK,EAALA,KAAF;kBAASiC,MAAM,EAAA;gBAAf,CAAD,CAhC/C;gBAkCQqR,YAlCR,GAkCqD,KAAA,CAAKnJ,UAAL,CAAgBnK,KAAhB,CAlCrD;;gBAAA,MAmCQ+O,UAAU,CAACzB,OAAXyB,IAAsBuE,YAAtBvE,IAAsC,KAAA,CAAK/O,KAAL,KAAeA,KAnC7D;kBAAA;kBAAA;gBAAA;;gBAAA,kCAoCasT,YApCb;;cAAA;gBAuCI,IAAI1M,aAAJ,EAAmB;kBACjB0M,YAAY,GAAGpL,SAAfoL;gBACD;;gBAEGC,eA3CR,GA4CMD,YAAY,IACZ,EAAE,aAAaA,YAAf,CADAA,IAEAtO,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,aAFzBsO,GAGIA,YAHJA,GAIIpL,SAhDV;gBAkDUsL,mBAlDV,GAkDqD;kBAC/C/M,QAAQ,EAAE,KAAA,CAAK+C,UAAL,CAAgBiK,WAAhB,CAA4B;oBACpCvR,IAAI,EAAEI,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;sBAAEzC,QAAQ,EAARA,QAAF;sBAAYK,KAAK,EAALA;oBAAZ,CAArBoC,CAD8B;oBAEpCoR,iBAAiB,EAAE,IAFiB;oBAGpCvQ,MAAM,EAAEa,UAH4B;oBAIpC2E,MAAM,EAANA;kBAJoC,CAA5B,CADqC;kBAO/C/B,aAAa,EAAE,IAPgC;kBAQ/CC,cAAc,EAAE,KAAA,CAAKqE,KAR0B;kBAS/CpE,SAAS,EAAE,IAToC;kBAU/CJ,aAAa,EAAE,KAAA,CAAKuC,GAV2B;kBAW/ClC,YAAY,EAAE,CAACkD,SAXgC;kBAY/CtD,UAAU,EAAE,KAZmC;kBAa/CM,wBAAwB,EAAxBA;gBAb+C,CAlDrD;gBAAA;gBAkEiB,OAAM0M,qBAAqB,CAAC;kBACvCC,SAAS,EAAE;oBAAA,OAAMpN,aAAa,CAACgN,mBAAD,CAAnB;kBAAA,CAD4B;kBAEvCrQ,MAAM,EAAEa,UAF+B;kBAGvC2E,MAAM,EAAEA,MAH+B;kBAIvC1G,MAAM,EAAA;gBAJiC,CAAD,CAA3B;;cAlEjB;gBAkEU0F,IAlEV;gBAwEIoB,eAAe;;gBAxEnB,MA2EMpB,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,GAAY,GAAZA,IAAI,CAAEkM,MAANlM,KAAY,IAAZA,GAAAA,KAAAA,CAAAA,GAAAA,GAAY,CAAA,IAAZA,MAAuB,mBAAvBA,IACAA,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,IAAY,GAAZA,IAAI,CAAEkM,MAANlM,KAAY,IAAZA,GAAAA,KAAAA,CAAAA,GAAAA,IAAY,CAAA,IAAZA,MAAuB,mBA5E7B;kBAAA;kBAAA;gBAAA;;gBAAA,kCA8EaA,IAAI,CAACkM,MA9ElB;;cAAA;gBAAA,MAiFQlM,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,IAAY,GAAZA,IAAI,CAAEkM,MAANlM,KAAY,IAAZA,GAAAA,KAAAA,CAAAA,GAAAA,IAAY,CAAA,IAAZA,MAAuB,SAjF/B;kBAAA;kBAAA;gBAAA;;gBAkFM3H,KAAK,GAAGyE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBkD,IAAI,CAACkM,MAALlM,CAAYhE,YAAhCc,CAARzE;gBACAH,QAAQ,GAAG8H,IAAI,CAACkM,MAALlM,CAAYhE,YAAvB9D;gBACAK,KAAK,GAAG,QAAA,CAAA,EAAA,EAAKA,KAAL,EAAeyH,IAAI,CAACkM,MAALlM,CAAYsG,QAAZtG,CAAqBzH,KAApC,CAARA;gBACA8D,UAAU,GAAGkK,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CACXE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBzG,IAAI,CAACkM,MAALlM,CAAYsG,QAAZtG,CAAqB9H,QAAzCuO,EAAmD,KAAA,CAAKtE,OAAxDsE,EACGvO,QAFQqO,CAAblK,CArFN,CA0FM;;gBACAsP,YAAY,GAAG,KAAA,CAAKnJ,UAAL,CAAgBnK,KAAhB,CAAfsT;;gBA3FN,MA6FQvE,UAAU,CAACzB,OAAXyB,IACAuE,YADAvE,IAEA,KAAA,CAAK/O,KAAL,KAAeA,KAFf+O,IAGA,CAACnI,aAhGT;kBAAA;kBAAA;gBAAA;;gBAAA,kCAqGe,QAAA,CAAA,EAAA,EAAK0M,YAAL,EAAiB;kBAAEtT,KAAK,EAALA;gBAAF,CAAjB,CArGf;;cAAA;gBAAA,MAyGQA,KAAK,KAAK,MAAVA,IAAoBA,KAAK,CAACkD,UAANlD,CAAiB,OAAjBA,CAzG5B;kBAAA;kBAAA;gBAAA;;gBA0GMyI,oBAAoB,CAAC;kBAAEpJ,GAAG,EAAE0E,EAAP;kBAAW9B,MAAM,EAAA;gBAAjB,CAAD,CAApBwG;gBA1GN,kCA2Ga,IAAIT,OAAJ,CAAmB,YAAM,CAAE,CAA3B,CA3Gb;;cAAA;gBAAA,eA+GMuL,eA/GN;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAgHO,OAAM,KAAA,CAAKrB,cAAL,CAAoBlS,KAApB,EAA2BmG,IAA3B,CACL,UAAC2N,GAAD;kBAAA,OAAU;oBACRnK,SAAS,EAAEmK,GAAG,CAAClP,IADP;oBAER6F,WAAW,EAAEqJ,GAAG,CAACrJ,WAFT;oBAGRH,OAAO,EAAEwJ,GAAG,CAACC,GAAJD,CAAQxJ,OAHT;oBAIRC,OAAO,EAAEuJ,GAAG,CAACC,GAAJD,CAAQvJ,OAJT;oBAKRC,OAAO,EAAE,CAAC,CAACsJ,GAAG,CAACC,GAAJD,CAAQE;kBALX,CAAV;gBAAA,CADK,CAAN;;cAhHP;gBAAA;;cAAA;gBA8GUnD,SA9GV;;gBAAA,MA0HQ7L,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YA1HjC;kBAAA;kBAAA;gBAAA;;gBAAA,WA2HqCkP,OAAO,CAAC,6BAAD,CA3H5C,EA2HcD,kBA3Hd,YA2HcA,kBA3Hd;;gBAAA,IA4HWA,kBAAkB,CAACpD,SAAS,CAAClH,SAAX,CA5H7B;kBAAA;kBAAA;gBAAA;;gBAAA,MA6Hc,IAAIzK,KAAJ,kEACqDW,QADrD,QA7Hd;;cAAA;gBAmII;;;;AAIG;gBACGsU,qBAxIV,GAyIMtD,SAAS,CAACrG,OAAVqG,KACC7L,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YAAzBA,IAAyC6L,SAAS,CAACtG,OADpDsG,CAzIN;gBA4IUuD,eA5IV,GA6IMvD,SAAS,CAACvG,OAAVuG,IAAqBA,SAAS,CAACtG,OAA/BsG,IAA0CA,SAAS,CAACrG,OA7I1D;gBAAA;gBA+IsB,OAAM,KAAA,CAAK6J,QAAL,CAAc,mBAAA,0CAAA;kBAAA;;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA,MAChCD,eAAe,IAAI,CAACD,qBADY;4BAAA;4BAAA;0BAAA;;0BAAA,MAEjBxM,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEJ,IAFW;4BAAA;4BAAA;0BAAA;;0BAAA,eAG9BI,IAH8B;0BAAA;0BAAA;;wBAAA;0BAAA;0BAI9B,OAAMnB,aAAa,CAAC;4BAClBC,QAAQ,EAAE,KAAA,CAAK+C,UAAL,CAAgBiK,WAAhB,CAA4B;8BACpCvR,IAAI,EAAEI,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;gCAAEzC,QAAQ,EAARA,QAAF;gCAAYK,KAAK,EAALA;8BAAZ,CAArBoC,CAD8B;8BAEpCa,MAAM,EAAEa,UAF4B;8BAGpC2E,MAAM,EAANA;4BAHoC,CAA5B,CADQ;4BAMlB9B,cAAc,EAAE,KAAA,CAAKqE,KANH;4BAOlBpE,SAAS,EAAE,IAPO;4BAQlBJ,aAAa,EAAE,KAAA,CAAKuC,GARF;4BASlBlC,YAAY,EAAE,CAACkD,SATG;4BAUlBtD,UAAU,EAAE,KAVM;4BAWlBM,wBAAwB,EAAxBA;0BAXkB,CAAD,CAAnB;;wBAJ8B;0BAAA;;wBAAA;0BAAA;0BAE1BM,IAF0B,SAE1BA,IAF0B;0BAAA,kCAkB3B;4BACL8C,KAAK,EAAE9C,IAAI,IAAI;0BADV,CAlB2B;;wBAAA;0BAAA,eAwBzB,EAxByB;0BAAA;0BAyB3B,OAAM,KAAA,CAAK4L,eAAL,CACXtC,SAAS,CAAClH,SADC,EAEX;0BACA;4BACE9J,QAAQ,EAARA,QADF;4BAEEK,KAAK,EAALA,KAFF;4BAGEiD,MAAM,EAAEY,EAHV;4BAIE4E,MAAM,EAANA,MAJF;4BAKEmB,OAAO,EAAE,KAAA,CAAKA,OALhB;4BAMEC,aAAa,EAAE,KAAA,CAAKA;0BANtB,CAHW,CAAN;;wBAzB2B;0BAAA;0BAAA;4BAwBlC7D,OAxBkC;4BAyBlCmE,KAzBkC;0BAAA;;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CAAA,EAAd,CAAN;;cA/ItB;gBAAA;gBA+IYA,KA/IZ,yBA+IYA,KA/IZ;;gBAuLI;gBACA;gBACA;gBACA,IAAIwG,SAAS,CAACtG,OAAVsG,IAAqB2C,mBAAmB,CAAC/M,QAA7C,EAAuD;kBAC/CS,QAD+C,GACpC,IAAIxH,GAAJ,CACf8T,mBAAmB,CAAC/M,QADL,EAEftB,MAAM,CAACgC,QAAPhC,CAAgBjD,IAFD,EAGfA,IAJmD;kBAKrD,OAAO,KAAA,CAAK+G,GAAL,CAAS/B,QAAT,CAAP;gBACD,CAhML,CAkMI;gBACA;;;gBACA,IACE,CAAC,KAAA,CAAK+C,SAAN,IACA4G,SAAS,CAACvG,OADV,IAEAtF,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,aAH3B,EAIE;kBACAwB,aAAa,CACXxH,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkBwU,mBAAlBxU,EAAuC;oBACrCgI,YAAY,EAAE,IADuB;oBAErCD,YAAY,EAAE,KAFuB;oBAGrCL,aAAa,EAAEH;kBAHsB,CAAvCvH,CADW,CAAbwH,CAMEsB,KANFtB,CAMQ,YAAM,CAAE,CANhBA;gBAOD;;gBAhNL,KAmNQqK,SAAS,CAACrG,OAnNlB;kBAAA;kBAAA;gBAAA;;gBAAA,KAqNoB2J,qBArNpB;kBAAA;kBAAA;gBAAA;;gBAAA;gBAuNc,OAAM,KAAA,CAAKE,QAAL,CAAc;kBAAA,OAClB,KAAA,CAAKG,cAAL,CACElS,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;oBACnBpC,KAAK,EAAE,QAAA,CAAA,EAAA,EAAKA,KAAL,EAAU;sBAAEqU,UAAU,EAAE;oBAAd,CAAV,CADY;oBAEnB1U,QAAQ,EAAE0D,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAevD,KAAfuD,IACNxD,aAAa,CACXF,QADW,EAEXsN,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiBnJ,UAAjBmJ,EAA6BtN,QAFlB,EAGXK,KAHW,CAAbH,CAIE0B,MALI8B,GAMN1D;kBARe,CAArByC,CADF,CADkB;gBAAA,CAAd,CAAN;;cAvNd;gBAAA,8BAqOcqF,IArOd;gBAAA;gBAAA;;cAAA;gBAAA,eAsOY0C,KAAK,CAACkK,UAtOlB;;cAAA;gBAAA;gBAoNMD,UApNN;kBAqNQC,UArNR;gBAAA;;cAAA;gBA0OIlK,KAAK,CAACwH,SAANxH,GAAkBrL,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkBqL,KAAK,CAACwH,SAAxB7S,EAAmCsV,UAAnCtV,CAAlBqL;gBACAwG,SAAS,CAACxG,KAAVwG,GAAkBxG,KAAlBwG;gBACAA,SAAS,CAAC7Q,KAAV6Q,GAAkB7Q,KAAlB6Q;gBACAA,SAAS,CAAC3Q,KAAV2Q,GAAkB3Q,KAAlB2Q;gBACAA,SAAS,CAAC7M,UAAV6M,GAAuB7M,UAAvB6M;gBACA,KAAA,CAAK1G,UAAL,CAAgBnK,KAAhB,IAAyB6Q,SAAzB;gBA/OJ,kCAiPWA,SAjPX;;cAAA;gBAAA;gBAAA;gBAAA,kCAmPW,KAAA,CAAKmC,oBAAL,CACLyB,CAAAA,GAAAA,QAAAA,EAAc,cAAdA,cADK,EAEL5U,QAFK,EAGLK,KAHK,EAIL6D,EAJK,EAKLgL,UALK,CAnPX;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAA,EAAA,E;IA2PC;;;WAEOQ,aACNzD,KADMyD,EAEN5H,IAFM4H,EAGNgD,WAHMhD,EAIS;MACf,KAAKzD,KAAL,GAAaA,KAAb;MAEA,OAAO,KAAKd,GAAL,CACLrD,IADK,EAEL,KAAKwC,UAAL,CAAgB,OAAhB,EAAyBR,SAFpB,EAGL4I,WAHK,CAAP;IAKD;IAED;;;AAGG;;;;WACHmC,wBAAeC,EAAfD,EAA2C;MACzC,KAAKtH,IAAL,GAAYuH,EAAZ;IACD;;;WAEDtF,yBAAgBtL,EAAhBsL,EAAqC;MACnC,IAAI,CAAC,KAAKlM,MAAV,EAAkB,OAAO,KAAP;;MAClB,yBAAgC,KAAKA,MAAL,CAAYN,KAAZ,CAAkB,GAAlB,CAAhC;MAAA;MAAA,IAAO+R,YAAP;MAAA,IAAqBC,OAArB;;MACA,gBAAgC9Q,EAAE,CAAClB,KAAHkB,CAAS,GAATA,CAAhC;MAAA;MAAA,IAAO+Q,YAAP;MAAA,IAAqBC,OAArB,iBAHmC,CAKnC;;;MACA,IAAIA,OAAO,IAAIH,YAAY,KAAKE,YAA5BC,IAA4CF,OAAO,KAAKE,OAA5D,EAAqE;QACnE,OAAO,IAAP;MACD,CARkC,CAUnC;;;MACA,IAAIH,YAAY,KAAKE,YAArB,EAAmC;QACjC,OAAO,KAAP;MACD,CAbkC,CAenC;MACA;MACA;MACA;;;MACA,OAAOD,OAAO,KAAKE,OAAnB;IACD;;;WAEDzF,sBAAavL,EAAbuL,EAA+B;MAC7B,iBAAsBvL,EAAE,CAAClB,KAAHkB,CAAS,GAATA,CAAtB;MAAA;MAAA;MAAA,IAASL,IAAT,4BAAgB,EAAhB,eAD6B,CAE7B;MACA;;;MACA,IAAIA,IAAI,KAAK,EAATA,IAAeA,IAAI,KAAK,KAA5B,EAAmC;QACjCyB,MAAM,CAAC6P,QAAP7P,CAAgB,CAAhBA,EAAmB,CAAnBA;QACA;MACD,CAP4B,CAS7B;;;MACA,IAAM8P,OAAO,GAAGC,kBAAkB,CAACxR,IAAD,CAAlC,CAV6B,CAW7B;;MACA,IAAMyR,IAAI,GAAGvC,QAAQ,CAACwC,cAATxC,CAAwBqC,OAAxBrC,CAAb;;MACA,IAAIuC,IAAJ,EAAU;QACRA,IAAI,CAACE,cAALF;QACA;MACD,CAhB4B,CAiB7B;MACA;;;MACA,IAAMG,MAAM,GAAG1C,QAAQ,CAAC2C,iBAAT3C,CAA2BqC,OAA3BrC,EAAoC,CAApCA,CAAf;;MACA,IAAI0C,MAAJ,EAAY;QACVA,MAAM,CAACD,cAAPC;MACD;IACF;;;WAEDtF,kBAAS7M,MAAT6M,EAAkC;MAChC,OAAO,KAAK7M,MAAL,KAAgBA,MAAvB;IACD;IAED;;;;;AAKG;;;;WACGqS,kBACJnW,GADImW,EAGyB;MAAA,IAD7BrS,MAC6B,uEADZ9D,GACY;MAAA,IAA7ByG,OAA6B,uEAAF,EAAE;;;;aAH/B,mBAAA,0CAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAKM2J,MALN,GAKetC,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiB9N,GAAjB8N,CALf;gBAOQtN,QAPR,GAO4B4P,MAP5B,CAOQ5P,QAPR,EAOkBK,KAPlB,GAO4BuP,MAP5B,CAOkBvP,KAPlB;;gBASE,IAAI8E,OAAO,CAACC,GAARD,CAAY2G,mBAAhB,EAAqC;kBACnC,IAAI7F,OAAO,CAAC6C,MAAR7C,KAAmB,KAAvB,EAA8B;oBAC5BjG,QAAQ,GAAGuO,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAqBvO,QAArBuO,EAA+B,KAAA,CAAKtE,OAApCsE,EAA6CvO,QAAxDA;oBACA4P,MAAM,CAAC5P,QAAP4P,GAAkB5P,QAAlB4P;oBACApQ,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;oBAEI4O,QALwB,GAKbd,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiBhK,MAAjBgK,CALa;oBAMtBgB,gBANsB,GAMHC,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CACvBH,QAAQ,CAACpO,QADcuO,EAEvB,KAAA,CAAKtE,OAFkBsE,CANG;oBAU5BH,QAAQ,CAACpO,QAAToO,GAAoBE,gBAAgB,CAACtO,QAArCoO;oBACAnI,OAAO,CAAC6C,MAAR7C,GAAiBqI,gBAAgB,CAACE,cAAjBF,IAAmC,KAAA,CAAKpE,aAAzDjE;oBACA3C,MAAM,GAAGb,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB2L,QAArB3L,CAATa;kBACD;gBACF;;gBAxBH;gBA0BgB,OAAM,KAAA,CAAKqG,UAAL,CAAgBqG,WAAhB,EAAN;;cA1BhB;gBA0BQtL,KA1BR;gBA2BMP,UA3BN,GA2BmBb,MA3BnB;gBA6BQwF,MA7BR,GA8BI,OAAO7C,OAAO,CAAC6C,MAAf,KAA0B,WAA1B,GACI7C,OAAO,CAAC6C,MAAR7C,IAAkBoC,SADtB,GAEI,KAAA,CAAKS,MAhCb;gBAAA;gBAkC4B,OAAMsD,iBAAiB,CAAC;kBAChD9I,MAAM,EAAEA,MADwC;kBAEhDwF,MAAM,EAAEA,MAFwC;kBAGhD1G,MAAM,EAAA;gBAH0C,CAAD,CAAvB;;cAlC5B;gBAkCQgO,iBAlCR;;gBAAA,MAwCMjL,OAAO,CAACC,GAARD,CAAY0G,mBAAZ1G,IAAmC7B,MAAM,CAACD,UAAPC,CAAkB,GAAlBA,CAxCzC;kBAAA;kBAAA;gBAAA;;gBAAA;gBA0CiC,OAAM2M,CAAAA,GAAAA,YAAAA,EAAsB,sBAAtBA,EAAN;;cA1CjC;gBAAA;gBA0CoBH,QA1CpB,yBA0CQD,UA1CR;gBA4CUQ,cA5CV,GA4C2BC,CAAAA,GAAAA,gBAAAA,EAAe,OAAfA,CACrB/L,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYsE,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUvF,MAAVuF,EAAkB,KAAA,CAAKC,MAAvBD,CAAZtE,EAA4C,IAA5CA,CADqB+L,EAErB5L,KAFqB4L,EAGrBR,QAHqBQ,EAIrBV,MAAM,CAACvP,KAJciQ,EAKrB,UAACC,CAAD;kBAAA,OAAe9L,mBAAmB,CAAC8L,CAAD,EAAI7L,KAAJ,CAAlC;gBAAA,CALqB4L,EAMrB,KAAA,CAAKrG,OANgBqG,CA5C3B;;gBAAA,KAqDQD,cAAc,CAACG,YArDvB;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAwDIrM,UAAU,GAAGmL,CAAAA,GAAAA,aAAAA,EAAY,YAAZA,CACXjB,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAegC,cAAc,CAAC/M,MAA9B+K,CADWiB,EAEX,KAAA,CAAKxG,MAFMwG,CAAbnL;;gBAKA,IAAIkM,cAAc,CAACI,WAAfJ,IAA8BA,cAAc,CAACvM,YAAjD,EAA+D;kBAC7D;kBACA;kBACA9D,QAAQ,GAAGqQ,cAAc,CAACvM,YAA1B9D;kBACA4P,MAAM,CAAC5P,QAAP4P,GAAkB5P,QAAlB4P;;kBAEA,IAAI,CAACQ,iBAAL,EAAwB;oBACtB5Q,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;kBACD;gBACF;;cAtEL;gBAwEEoQ,MAAM,CAAC5P,QAAP4P,GAAkBnL,mBAAmB,CAACmL,MAAM,CAAC5P,QAAR,EAAkB0E,KAAlB,CAArCkL;;gBAEA,IAAIlM,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAekM,MAAM,CAAC5P,QAAtB0D,CAAJ,EAAqC;kBACnC1D,QAAQ,GAAG4P,MAAM,CAAC5P,QAAlBA;kBACA4P,MAAM,CAAC5P,QAAP4P,GAAkB5P,QAAlB4P;kBACAzQ,MAAM,CAACC,MAAPD,CACEkB,KADFlB,EAEEyB,CAAAA,GAAAA,aAAAA,EAAe,eAAfA,CAAgBJ,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcoP,MAAM,CAAC5P,QAArBQ,CAAhBI,EACEoN,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAU1K,MAAV0K,EAAkBhO,QADpBY,KAEK,EAJPzB;;kBAOA,IAAI,CAACiR,iBAAL,EAAwB;oBACtB5Q,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;kBACD;gBACF,CAvFH,CAyFE;;;gBAzFF,MA0FM2F,OAAO,CAACC,GAARD,CAAY4C,QAAZ5C,KAAyB,YA1F/B;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;gBAkGe,OAAM2O,qBAAqB,CAAC;kBACvCC,SAAS,EAAE;oBAAA,OACTpN,aAAa,CAAC;sBACZC,QAAQ,EAAE,KAAA,CAAK+C,UAAL,CAAgBiK,WAAhB,CAA4B;wBACpCvR,IAAI,EAAEI,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqB;0BAAEzC,QAAQ,EAARA,QAAF;0BAAYK,KAAK,EAALA;wBAAZ,CAArBoC,CAD8B;wBAEpCoR,iBAAiB,EAAE,IAFiB;wBAGpCvQ,MAAM,EAAEa,UAH4B;wBAIpC2E,MAAM,EAANA;sBAJoC,CAA5B,CADE;sBAOZ/B,aAAa,EAAE,IAPH;sBAQZC,cAAc,EAAE,KAAA,CAAKqE,KART;sBASZpE,SAAS,EAAE,IATC;sBAUZJ,aAAa,EAAE,KAAA,CAAKuC,GAVR;sBAWZlC,YAAY,EAAE,CAAC,KAAA,CAAKkD,SAXR;sBAYZtD,UAAU,EAAE;oBAZA,CAAD,CADJ;kBAAA,CAD4B;kBAgBvCxD,MAAM,EAAEA,MAhB+B;kBAiBvCwF,MAAM,EAAEA,MAjB+B;kBAkBvC1G,MAAM,EAAA;gBAlBiC,CAAD,CAA3B;;cAlGf;gBAkGQ0F,IAlGR;;gBAuHE;;;AAGG;gBACH,IAAIA,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEkM,MAANlM,CAAawJ,IAAbxJ,MAAsB,SAA1B,EAAqC;kBACnC8H,MAAM,CAAC5P,QAAP4P,GAAkB9H,IAAI,CAACkM,MAALlM,CAAYhE,YAA9B8L;kBACA5P,QAAQ,GAAG8H,IAAI,CAACkM,MAALlM,CAAYhE,YAAvB9D;kBACAK,KAAK,GAAG,QAAA,CAAA,EAAA,EAAKA,KAAL,EAAeyH,IAAI,CAACkM,MAALlM,CAAYsG,QAAZtG,CAAqBzH,KAApC,CAARA;kBACA8D,UAAU,GAAG2D,IAAI,CAACkM,MAALlM,CAAYsG,QAAZtG,CAAqB9H,QAAlCmE;kBACA3E,GAAG,GAAGiD,CAAAA,GAAAA,UAAAA,EAAoB,oBAApBA,CAAqBmN,MAArBnN,CAANjD;gBACD;gBAED;;;AAGG;;;gBAtIL,MAuIMsI,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEkM,MAANlM,CAAawJ,IAAbxJ,MAAsB,mBAvI5B;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBA2IQ3H,KA3IR,GA2IgByE,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoB5E,QAApB4E,CA3IhB;gBAAA;gBA6IE,OAAMuD,OAAO,CAAC4H,GAAR5H,CAAY,CAChB,KAAA,CAAKwB,UAAL,CAAgBiM,MAAhB,CAAuBzV,KAAvB,EAA8BmG,IAA9B,CAAmC,UAACuP,KAAD,EAAW;kBAC5C,OAAOA,KAAK,GACRlP,aAAa,CAAC;oBACZC,QAAQ,EACNkB,CAAAA,IAAI,IAAA,IAAJA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAElB,QAANkB,KACA,KAAA,CAAK6B,UAAL,CAAgBiK,WAAhB,CAA4B;sBAC1BvR,IAAI,EAAE7C,GADoB;sBAE1B8D,MAAM,EAAEa,UAFkB;sBAG1B2E,MAAM,EAAEA;oBAHkB,CAA5B,CAHU;oBAQZ9B,cAAc,EAAE,KARJ;oBASZC,SAAS,EAAE,IATC;oBAUZJ,aAAa,EAAE,KAAA,CAAKuC,GAVR;oBAWZlC,YAAY,EAAE,CAAC,KAAA,CAAKkD,SAXR;oBAYZtD,UAAU,EAAE,IAZA;oBAaZM,wBAAwB,EACtBnB,OAAO,CAACmB,wBAARnB,IACCA,OAAO,CAAC6P,QAAR7P,IACC,CAAC,CAACd,OAAO,CAACC,GAARD,CAAY4Q;kBAhBN,CAAD,CAAbpP,CAiBGL,IAjBHK,CAiBQ;oBAAA,OAAM,KAAN;kBAAA,CAjBRA,CADQ,GAmBR,KAnBJ;gBAoBD,CArBD,CADgB,EAuBhB,KAAA,CAAKgD,UAAL,CAAgB1D,OAAO,CAAC6P,QAAR7P,GAAmB,UAAnBA,GAAgC,UAAhD,EAA4D9F,KAA5D,CAvBgB,CAAZgI,CAAN;;cA7IF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAA,EAAA,E;IAsKC;;;WAEKkK,wBAAelS,KAAfkS,EAA4B;;;aAAlC,mBAAA,0CAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACQnJ,eADR,GAC0BH,mBAAmB,CAAC;kBAAE5I,KAAK,EAALA,KAAF;kBAASiC,MAAM,EAAA;gBAAf,CAAD,CAD7C;gBAAA;gBAAA;gBAI4B,OAAM,KAAA,CAAKuH,UAAL,CAAgBsM,QAAhB,CAAyB9V,KAAzB,CAAN;;cAJ5B;gBAIU6V,eAJV;gBAKI9M,eAAe;gBALnB,kCAOW8M,eAPX;;cAAA;gBAAA;gBAAA;gBASI9M,eAAe;gBATnB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAA,EAAA,E;IAYC;;;WAEDsL,kBAAY0B,EAAZ1B,EAA8C;MAAA;;MAC5C,IAAIlV,SAAS,GAAG,KAAhB;;MACA,IAAM0J,MAAM,GAAG,SAATA,MAAS,GAAM;QACnB1J,SAAS,GAAG,IAAZA;MACD,CAFD;;MAGA,KAAK2J,GAAL,GAAWD,MAAX;MACA,OAAOkN,EAAE,GAAG5P,IAAL4P,CAAU,UAACpO,IAAD,EAAU;QACzB,IAAIkB,MAAM,KAAK,MAAI,CAACC,GAApB,EAAyB;UACvB,MAAI,CAACA,GAAL,GAAW,IAAX;QACD;;QAED,IAAI3J,SAAJ,EAAe;UACb,IAAM4I,GAAG,GAAQ,IAAI7I,KAAJ,CAAU,iCAAV,CAAjB;UACA6I,GAAG,CAAC5I,SAAJ4I,GAAgB,IAAhBA;UACA,MAAMA,GAAN;QACD;;QAED,OAAOJ,IAAP;MACD,CAZMoO,CAAP;IAaD;;;WAEDvB,wBAAe/N,QAAf+N,EAAiC;MAC/B;MACA,OAAOhO,aAAa,CAAC;QACnBC,QAAQ,EAARA,QADmB;QAEnBI,cAAc,EAAE,IAFG;QAGnBC,SAAS,EAAE,KAHQ;QAInBJ,aAAa,EAAE,KAAKuC,GAJD;QAKnBlC,YAAY,EAAE,KALK;QAMnBJ,UAAU,EAAE;MANO,CAAD,CAAbH,CAOJL,IAPIK,CAOC;QAAA,IAAGc,IAAH,SAAGA,IAAH;QAAA,OAAe;UAAEK,IAAI,EAAEL;QAAR,CAAf;MAAA,CAPDd,CAAP;IAQD;;;WAED2M,yBACExJ,SADFwJ,EAEE6C,GAFF7C,EAGgB;MACd,IAAmB1J,GAAnB,GAA2B,KAAKU,UAAL,CAAgB,OAAhB,CAA3B,CAAQR,SAAR;;MACA,IAAMsM,OAAO,GAAG,KAAKhL,QAAL,CAAcxB,GAAd,CAAhB;;MACAuM,GAAG,CAACC,OAAJD,GAAcC,OAAdD;MACA,OAAOE,CAAAA,GAAAA,MAAAA,EAAmB,mBAAnBA,CAA4CzM,GAA5CyM,EAAiD;QACtDD,OAAO,EAAPA,OADsD;QAEtDtM,SAAS,EAATA,SAFsD;QAGtD1H,MAAM,EAAE,IAH8C;QAItD+T,GAAG,EAAHA;MAJsD,CAAjDE,CAAP;IAMD;;;SAED,eAAoB;MAClB,OAAO,KAAKpK,KAAL,CAAW9L,KAAlB;IACD;;;SAED,eAAuB;MACrB,OAAO,KAAK8L,KAAL,CAAWjM,QAAlB;IACD;;;SAED,eAA4B;MAC1B,OAAO,KAAKiM,KAAL,CAAW5L,KAAlB;IACD;;;SAED,eAAqB;MACnB,OAAO,KAAK4L,KAAL,CAAW3I,MAAlB;IACD;;;SAED,eAAiC;MAC/B,OAAO,KAAK2I,KAAL,CAAWnD,MAAlB;IACD;;;SAED,eAA0B;MACxB,OAAO,KAAKmD,KAAL,CAAWjC,UAAlB;IACD;;;SAED,eAAyB;MACvB,OAAO,KAAKiC,KAAL,CAAW7B,SAAlB;IACD;;;;;;AAlkDD,MAvCyB,CAuClBb,MAAP,GAA0CC,CAAAA,GAAAA,KAAAA,EAAI,OAAJA,EAA1C;;AA4kDF,SAAS4C,iBAAT,CACEnG,OADF,EAEoB;EAClB,OAAOkC,OAAO,CAACC,OAARD,CAAgBlC,OAAO,CAAC7D,MAAR6D,CAAe0D,UAAf1D,CAA0BiK,aAA1BjK,EAAhBkC,EAA2D7B,IAA3D6B,CACL,UAACmO,UAAD,EAAgB;IACd,kBAAiCtI,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAU/H,OAAO,CAAC3C,MAAlB0K,CAAjC;IAAA,IAAkB5N,UAAlB,eAAQJ,QAAR;;IACA,IAAMqP,SAAS,GAAGtP,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYK,UAAZL,IACdsO,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAejO,UAAfiO,CADctO,GAEdK,UAFJ;IAIA,IAAMmW,KAAK,GAAGD,UAAU,IAAA,IAAVA,GAAAA,KAAAA,CAAAA,GAAAA,UAAU,CAAEhP,QAA1B;IACA,OACE,CAAC,CAACiP,KAAF,IAAW,IAAIC,MAAJ,CAAWD,KAAX,EAAkBtR,IAAlB,CAAuB4D,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUwG,SAAVxG,EAAqB5C,OAAO,CAAC6C,MAA7BD,CAAvB,CADb;EAGD,CAXIV,CAAP;AAaD;;AAED,SAAS2L,qBAAT,CACE7N,OADF,EAEE;EACA,OAAOmG,iBAAiB,CAACnG,OAAD,CAAjBmG,CAA2B9F,IAA3B8F,CAAgC,UAACC,OAAD,EAAa;IAClD,IAAIA,OAAO,IAAIpG,OAAO,CAAC8N,SAAvB,EAAkC;MAChC,OAAO9N,OAAO,CACX8N,SADI9N,GAEJK,IAFIL,CAEC,UAAC6B,IAAD;QAAA,OACJ2O,iBAAiB,CAAC3O,IAAI,CAAClB,QAAN,EAAgBkB,IAAI,CAACvB,QAArB,EAA+BN,OAA/B,CAAjBwQ,CAAyDnQ,IAAzDmQ,CACE,UAACzC,MAAD;UAAA,OAAa;YACXpN,QAAQ,EAAEkB,IAAI,CAAClB,QADJ;YAEXc,IAAI,EAAEI,IAAI,CAACJ,IAFA;YAGXnB,QAAQ,EAAEuB,IAAI,CAACvB,QAHJ;YAIXkB,IAAI,EAAEK,IAAI,CAACL,IAJA;YAKXuM,MAAM,EAANA;UALW,CAAb;QAAA,CADFyC,CADI;MAAA,CAFDxQ,EAaJgC,KAbIhC,CAaE,UAACyQ,IAAD,EAAU;QACf;;;;AAIG;QACH,OAAO,IAAP;MACD,CApBIzQ,CAAP;IAqBD;;IAED,OAAO,IAAP;EACD,CA1BMmG,CAAP;AA2BD;;AAED,SAASqK,iBAAT,CACEE,MADF,EAEEpQ,QAFF,EAGEN,OAHF,EAIE;EACA,IAAM2Q,UAAU,GAAG;IACjB3L,QAAQ,EAAEhF,OAAO,CAAC7D,MAAR6D,CAAegF,QADR;IAEjB4L,IAAI,EAAE;MAAE5M,OAAO,EAAEhE,OAAO,CAAC7D,MAAR6D,CAAegE;IAA1B,CAFW;IAGjB6M,aAAa,EAAEC,OAAO,CAAC5R,OAAO,CAACC,GAARD,CAAY6R,qBAAb;EAHL,CAAnB;EAKA,IAAMC,aAAa,GAAG1Q,QAAQ,CAACF,OAATE,CAAiByB,GAAjBzB,CAAqB,kBAArBA,CAAtB;EAEA,IAAI2Q,aAAa,GACfD,aAAa,IAAI1Q,QAAQ,CAACF,OAATE,CAAiByB,GAAjBzB,CAAqB,uBAArBA,CADnB;EAGA,IAAM4Q,WAAW,GAAG5Q,QAAQ,CAACF,OAATE,CAAiByB,GAAjBzB,CAAqB,gBAArBA,CAApB;;EAEA,IACE4Q,WAAW,IACX,CAACD,aADDC,IAEA,CAACA,WAAW,CAACjV,QAAZiV,CAAqB,sBAArBA,CAFDA,IAGA,CAACA,WAAW,CAACjV,QAAZiV,CAAqB,SAArBA,CAHDA,IAIA,CAACA,WAAW,CAACjV,QAAZiV,CAAqB,MAArBA,CALH,EAME;IACA;IACAD,aAAa,GAAGC,WAAhBD;EACD;;EAED,IAAIA,aAAJ,EAAmB;IACjB,IAAIA,aAAa,CAAC7T,UAAd6T,CAAyB,GAAzBA,CAAJ,EAAmC;MACjC,IAAME,mBAAmB,GAAG9J,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiB4J,aAAjB5J,CAA5B;MACA,IAAM+J,YAAY,GAAGC,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBF,mBAAmB,CAACpX,QAAxCsX,EAAkD;QACrEV,UAAU,EAAVA,UADqE;QAErEW,SAAS,EAAE;MAF0D,CAAlDD,CAArB;MAKA,IAAIE,UAAU,GAAG5S,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoByS,YAAY,CAACrX,QAAjC4E,CAAjB;MACA,OAAOuD,OAAO,CAAC4H,GAAR5H,CAAY,CACjBlC,OAAO,CAAC7D,MAAR6D,CAAe0D,UAAf1D,CAA0B+J,WAA1B/J,EADiB,EAEjBgK,CAAAA,GAAAA,YAAAA,EAAsB,sBAAtBA,EAFiB,CAAZ9H,EAGJ7B,IAHI6B,CAGC,iBAA4C;QAAA;QAAA,IAA1CzD,KAA0C;QAAA,IAArBoL,QAAqB,YAAjCD,UAAiC;;QAClD,IAAI3L,EAAE,GAAG2E,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAUwO,YAAY,CAACrX,QAAvB6I,EAAiCwO,YAAY,CAACvO,MAA9CD,CAAT;;QAEA,IACEnF,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAeQ,EAAfR,KACC,CAACuT,aAAD,IACCvS,KAAK,CAACxC,QAANwC,CACE6J,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBF,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAenK,EAAfmK,CAApBE,EAAwCtI,OAAO,CAAC7D,MAAR6D,CAAegE,OAAvDsE,EACGvO,QAFL0E,CAHJ,EAOE;UACA,IAAM+S,YAAY,GAAGH,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CACnBhK,CAAAA,GAAAA,iBAAAA,EAAgB,gBAAhBA,CAAiBqJ,MAAjBrJ,EAAyBtN,QADNsX,EAEnB;YAAEC,SAAS,EAAE;UAAb,CAFmBD,CAArB;UAKApT,EAAE,GAAGK,CAAAA,GAAAA,YAAAA,EAAW,WAAXA,CAAYkT,YAAY,CAACzX,QAAzBuE,CAALL;UACAkT,mBAAmB,CAACpX,QAApBoX,GAA+BlT,EAA/BkT;QACD;;QAED,IAAIjS,OAAO,CAACC,GAARD,CAAY0G,mBAAhB,EAAqC;UACnC,IAAMjK,MAAM,GAAG0O,CAAAA,GAAAA,gBAAAA,EAAe,OAAfA,CACbpM,EADaoM,EAEb5L,KAFa4L,EAGbR,QAHaQ,EAIb8G,mBAAmB,CAAC/W,KAJPiQ,EAKb,UAACoH,IAAD;YAAA,OAAkBjT,mBAAmB,CAACiT,IAAD,EAAOhT,KAAP,CAArC;UAAA,CALa4L,EAMbrK,OAAO,CAAC7D,MAAR6D,CAAegE,OANFqG,CAAf;;UASA,IAAI1O,MAAM,CAAC6O,WAAX,EAAwB;YACtB2G,mBAAmB,CAACpX,QAApBoX,GAA+BxV,MAAM,CAACwM,QAAPxM,CAAgB5B,QAA/CoX;YACAlT,EAAE,GAAGkT,mBAAmB,CAACpX,QAAzBkE;YACA/E,MAAM,CAACC,MAAPD,CAAciY,mBAAmB,CAAC/W,KAAlClB,EAAyCyC,MAAM,CAACwM,QAAPxM,CAAgBvB,KAAzDlB;UACD;QACF,CAfD,MAeO,IAAI,CAACuF,KAAK,CAACxC,QAANwC,CAAe8S,UAAf9S,CAAL,EAAiC;UACtC,IAAMiT,gBAAgB,GAAGlT,mBAAmB,CAAC+S,UAAD,EAAa9S,KAAb,CAA5C;;UAEA,IAAIiT,gBAAgB,KAAKH,UAAzB,EAAqC;YACnCA,UAAU,GAAGG,gBAAbH;UACD;QACF;;QAED,IAAM1T,YAAY,GAAG,CAACY,KAAK,CAACxC,QAANwC,CAAe8S,UAAf9S,CAAD,GACjBD,mBAAmB,CACjB8J,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CACEF,CAAAA,GAAAA,eAAAA,EAAc,cAAdA,CAAe+I,mBAAmB,CAACpX,QAAnCqO,CADFE,EAEEtI,OAAO,CAAC7D,MAAR6D,CAAegE,OAFjBsE,EAGEvO,QAJe,EAKjB0E,KALiB,CADF,GAQjB8S,UARJ;;QAUA,IAAI9T,CAAAA,GAAAA,UAAAA,EAAc,cAAdA,CAAeI,YAAfJ,CAAJ,EAAkC;UAChC,IAAM2I,OAAO,GAAGzL,CAAAA,GAAAA,aAAAA,EAAe,eAAfA,CAAgBJ,CAAAA,GAAAA,WAAAA,EAAa,aAAbA,CAAcsD,YAAdtD,CAAhBI,EAA6CsD,EAA7CtD,CAAhB;UACAzB,MAAM,CAACC,MAAPD,CAAciY,mBAAmB,CAAC/W,KAAlClB,EAAyCkN,OAAO,IAAI,EAApDlN;QACD;;QAED,OAAO;UACLmS,IAAI,EAAE,SADD;UAELlD,QAAQ,EAAEgJ,mBAFL;UAGLtT,YAAY,EAAZA;QAHK,CAAP;MAKD,CAlEMqE,CAAP;IAmED;;IAED,IAAMyP,GAAG,GAAG5J,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAU2I,MAAV3I,CAAZ;IACA,IAAMhO,QAAQ,GAAG6X,CAAAA,GAAAA,uBAAAA,EAAsB,sBAAtBA,CAAuB,QAAA,CAAA,EAAA,EACnCP,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBM,GAAG,CAAC5X,QAAxBsX,EAAkC;MAAEV,UAAU,EAAVA,UAAF;MAAcW,SAAS,EAAE;IAAzB,CAAlCD,CADmC,EAC+B;MACrEpN,aAAa,EAAEjE,OAAO,CAAC7D,MAAR6D,CAAeiE,aADuC;MAErE4N,OAAO,EAAE;IAF4D,CAD/B,CAAvBD,CAAjB;IAMA,OAAO1P,OAAO,CAACC,OAARD,CAAgB;MACrBmJ,IAAI,EAAE,mBADe;MAErBG,WAAW,YAAKzR,QAAL,SAAgB4X,GAAG,CAACvX,KAApB,SAA4BuX,GAAG,CAAC/T,IAAhC;IAFU,CAAhBsE,CAAP;EAID;;EAED,IAAM4P,cAAc,GAAGxR,QAAQ,CAACF,OAATE,CAAiByB,GAAjBzB,CAAqB,mBAArBA,CAAvB;;EAEA,IAAIwR,cAAJ,EAAoB;IAClB,IAAIA,cAAc,CAAC1U,UAAf0U,CAA0B,GAA1BA,CAAJ,EAAoC;MAClC,IAAMH,IAAG,GAAG5J,CAAAA,GAAAA,UAAAA,EAAS,SAATA,CAAU+J,cAAV/J,CAAZ;;MACA,IAAMhO,UAAQ,GAAG6X,CAAAA,GAAAA,uBAAAA,EAAsB,sBAAtBA,CAAuB,QAAA,CAAA,EAAA,EACnCP,CAAAA,GAAAA,oBAAAA,EAAmB,mBAAnBA,CAAoBM,IAAG,CAAC5X,QAAxBsX,EAAkC;QAAEV,UAAU,EAAVA,UAAF;QAAcW,SAAS,EAAE;MAAzB,CAAlCD,CADmC,EAC+B;QACrEpN,aAAa,EAAEjE,OAAO,CAAC7D,MAAR6D,CAAeiE,aADuC;QAErE4N,OAAO,EAAE;MAF4D,CAD/B,CAAvBD,CAAjB;;MAMA,OAAO1P,OAAO,CAACC,OAARD,CAAgB;QACrBmJ,IAAI,EAAE,mBADe;QAErBE,KAAK,YAAKxR,UAAL,SAAgB4X,IAAG,CAACvX,KAApB,SAA4BuX,IAAG,CAAC/T,IAAhC,CAFgB;QAGrB0N,MAAM,YAAKvR,UAAL,SAAgB4X,IAAG,CAACvX,KAApB,SAA4BuX,IAAG,CAAC/T,IAAhC;MAHe,CAAhBsE,CAAP;IAKD;;IAED,OAAOA,OAAO,CAACC,OAARD,CAAgB;MACrBmJ,IAAI,EAAE,mBADe;MAErBG,WAAW,EAAEsG;IAFQ,CAAhB5P,CAAP;EAID;;EAED,OAAOA,OAAO,CAACC,OAARD,CAAgB;IAAEmJ,IAAI,EAAE;EAAR,CAAhBnJ,CAAP;AACD;;kBArzDoBgB,M","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports.default = void 0;\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _removeTrailingSlash = require(\"./utils/remove-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _script = require(\"../../../client/script\");\nvar _isError = _interop_require_wildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interop_require_default(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interop_require_default(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _formatUrl = require(\"./utils/format-url\");\nvar _detectDomainLocale = require(\"../../../client/detect-domain-locale\");\nvar _parsePath = require(\"./utils/parse-path\");\nvar _addLocale = require(\"../../../client/add-locale\");\nvar _removeLocale = require(\"../../../client/remove-locale\");\nvar _removeBasePath = require(\"../../../client/remove-base-path\");\nvar _addBasePath = require(\"../../../client/add-base-path\");\nvar _hasBasePath = require(\"../../../client/has-base-path\");\nvar _getNextPathnameInfo = require(\"./utils/get-next-pathname-info\");\nvar _formatNextPathnameInfo = require(\"./utils/format-next-pathname-info\");\nvar _compareStates = require(\"./utils/compare-states\");\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils).isAbsoluteUrl(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omit(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nconst backgroundCache = {};\nfunction fetchNextData({ dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  }) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    var ref1;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: isPrefetch ? {\n                purpose: 'prefetch'\n            } : {},\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {}\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {}\n                        };\n                    }\n                    if (!hasMiddleware && response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text\n                            };\n                        }\n                    }\n                    const error = new Error(`Failed to load static props`);\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            delete inflightCache[cacheKey];\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url , router  }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route , router  })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error(`Abort fetching component for route: \"${route}\"`);\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch (e) {}\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    change(method, url, as, options, forcedScroll) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (!isLocalURL(url)) {\n                handleHardNavigation({\n                    url,\n                    router: _this\n                });\n                return false;\n            }\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n            const isQueryUpdating = options._h;\n            const shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n            const nextState = _extends({}, _this.state);\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            // or a navigation has occurred\n            const readyStateChange = _this.isReady !== true;\n            _this.isReady = true;\n            const isSsr = _this.isSsr;\n            if (!isQueryUpdating) {\n                _this.isSsr = false;\n            }\n            // if a route transition is already in progress before\n            // the query updating is triggered ignore query updating\n            if (isQueryUpdating && _this.clc) {\n                return false;\n            }\n            const prevLocale = nextState.locale;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n                if (typeof options.locale === 'undefined') {\n                    options.locale = nextState.locale;\n                }\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                if (localePathResult.detectedLocale) {\n                    nextState.locale = localePathResult.detectedLocale;\n                    parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);\n                    as = (0, _formatUrl).formatWithValidation(parsedAs);\n                    url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);\n                }\n                let didNavigate = false;\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    var ref;\n                    // if the locale isn't configured hard navigate to show 404 page\n                    if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {\n                        parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);\n                        handleHardNavigation({\n                            url: (0, _formatUrl).formatWithValidation(parsedAs),\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale);\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    // if we are navigating to a domain locale ensure we redirect to the\n                    // correct domain\n                    if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                        const asNoBasePath = (0, _removeBasePath).removeBasePath(as);\n                        handleHardNavigation({\n                            url: `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${(0, _addBasePath).addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`,\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                if (didNavigate) {\n                    return new Promise(()=>{});\n                }\n            }\n            // marking route changes as a navigation start entry\n            if (_utils.ST) {\n                performance.mark('routeChange');\n            }\n            const { shallow =false , scroll =true  } = options;\n            const routeProps = {\n                shallow\n            };\n            if (_this._inFlightRoute && _this.clc) {\n                if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                }\n                _this.clc();\n                _this.clc = null;\n            }\n            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n            _this._inFlightRoute = as;\n            const localeChange = prevLocale !== nextState.locale;\n            // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                    scroll: false\n                }));\n                if (scroll) {\n                    _this.scrollToHash(cleanedAs);\n                }\n                try {\n                    yield _this.set(nextState, _this.components[nextState.route], null);\n                } catch (err) {\n                    if ((0, _isError).default(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return true;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n            let pages, rewrites;\n            try {\n                [pages, { __rewrites: rewrites  }] = yield Promise.all([\n                    _this.pageLoader.getPageList(),\n                    (0, _routeLoader).getClientBuildManifest(),\n                    _this.pageLoader.getMiddleware(), \n                ]);\n            } catch (err) {\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                method = 'replaceState';\n            }\n            // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n            let resolvedAs = as;\n            // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n            // we don't attempt resolve asPath when we need to execute\n            // middleware as the resolving will occur server-side\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: _this\n            });\n            if (options.shallow && isMiddlewareMatch) {\n                pathname = _this.pathname;\n            }\n            if (shouldResolveHref && pathname !== '/_error') {\n                options._shouldResolveHref = true;\n                if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                    const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                    if (rewritesResult.externalDest) {\n                        handleHardNavigation({\n                            url: as,\n                            router: _this\n                        });\n                        return true;\n                    }\n                    if (!isMiddlewareMatch) {\n                        resolvedAs = rewritesResult.asPath;\n                    }\n                    if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                        // if this directly matches a page we need to update the href to\n                        // allow the correct page chunk to be loaded\n                        pathname = rewritesResult.resolvedHref;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                } else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                    if (parsed.pathname !== pathname) {\n                        pathname = parsed.pathname;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                }\n            }\n            if (!isLocalURL(as)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n                }\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            let routeMatch = false;\n            if ((0, _isDynamic).isDynamicRoute(route)) {\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                const asPathname = parsedAs.pathname;\n                const routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                const shouldInterpolate = route === asPathname;\n                const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param]);\n                    if (missingParams.length > 0 && !isMiddlewareMatch) {\n                        if (process.env.NODE_ENV !== 'production') {\n                            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                        }\n                        throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                    }\n                } else if (shouldInterpolate) {\n                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                        pathname: interpolatedAs.result,\n                        query: omit(query, interpolatedAs.params)\n                    }));\n                } else {\n                    // Merge params into `query`, overwriting any specified in search\n                    Object.assign(query, routeMatch);\n                }\n            }\n            if (!isQueryUpdating) {\n                Router.events.emit('routeChangeStart', as, routeProps);\n            }\n            try {\n                var ref2, ref3;\n                let routeInfo = yield _this.getRouteInfo({\n                    route,\n                    pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps,\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    hasMiddleware: isMiddlewareMatch\n                });\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                    pathname = routeInfo.route || route;\n                    route = pathname;\n                    if (!routeProps.shallow) {\n                        query = Object.assign({}, routeInfo.query || {}, query);\n                    }\n                    if (routeMatch && pathname !== parsed.pathname) {\n                        Object.keys(routeMatch).forEach((key)=>{\n                            if (routeMatch && query[key] === routeMatch[key]) {\n                                delete query[key];\n                            }\n                        });\n                    }\n                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                        let rewriteAs = prefixedAs;\n                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                        }\n                        if (process.env.__NEXT_I18N_SUPPORT) {\n                            const localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);\n                            nextState.locale = localeResult.detectedLocale || nextState.locale;\n                            rewriteAs = localeResult.pathname;\n                        }\n                        const routeRegex = (0, _routeRegex).getRouteRegex(pathname);\n                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(rewriteAs);\n                        if (curRouteMatch) {\n                            Object.assign(query, curRouteMatch);\n                        }\n                    }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if ('type' in routeInfo) {\n                    if (routeInfo.type === 'redirect-internal') {\n                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                    } else {\n                        handleHardNavigation({\n                            url: routeInfo.destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                }\n                let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n                const component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                    const scripts = [].concat(component.unstable_scriptLoader());\n                    scripts.forEach((script)=>{\n                        (0, _script).handleClientScriptLoad(script.props);\n                    });\n                }\n                // handle redirect on client-transition\n                if ((__N_SSG || __N_SSP) && props) {\n                    if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                        // Use the destination from redirect without adding locale\n                        options.locale = false;\n                        const destination = props.pageProps.__N_REDIRECT;\n                        // check if destination is internal (resolves to a page) and attempt\n                        // client-navigation if it is falling back to hard navigation if\n                        // it's not\n                        if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);\n                            return _this.change(method, newUrl, newAs, options);\n                        }\n                        handleHardNavigation({\n                            url: destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                    nextState.isPreview = !!props.__N_PREVIEW;\n                    // handle SSG data 404\n                    if (props.notFound === SSG_DATA_NOT_FOUND) {\n                        let notFoundRoute;\n                        try {\n                            yield _this.fetchComponent('/404');\n                            notFoundRoute = '/404';\n                        } catch (_) {\n                            notFoundRoute = '/_error';\n                        }\n                        routeInfo = yield _this.getRouteInfo({\n                            route: notFoundRoute,\n                            pathname: notFoundRoute,\n                            query,\n                            as,\n                            resolvedAs,\n                            routeProps: {\n                                shallow: false\n                            },\n                            locale: nextState.locale,\n                            isPreview: nextState.isPreview\n                        });\n                        if ('type' in routeInfo) {\n                            throw new Error(`Unexpected middleware effect on /404`);\n                        }\n                    }\n                }\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n                _this.changeState(method, url, as, options);\n                if (isQueryUpdating && pathname === '/_error' && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    props.pageProps.statusCode = 500;\n                }\n                var _route;\n                // shallow routing is only allowed for same page URL changes.\n                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                var _scroll;\n                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                const resetScroll = shouldScroll ? {\n                    x: 0,\n                    y: 0\n                } : null;\n                // the new state that the router gonna set\n                const upcomingRouterState = _extends({}, nextState, {\n                    route,\n                    pathname,\n                    query,\n                    asPath: cleanedAs,\n                    isFallback: false\n                });\n                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                const canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (!canSkipUpdating) {\n                    yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch((e)=>{\n                        if (e.cancelled) error = error || e;\n                        else throw e;\n                    });\n                    if (error) {\n                        if (!isQueryUpdating) {\n                            Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                        }\n                        throw error;\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                        if (nextState.locale) {\n                            document.documentElement.lang = nextState.locale;\n                        }\n                    }\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeComplete', as, routeProps);\n                    }\n                    // A hash mark # is the optional last part of a URL\n                    const hashRegex = /#.+$/;\n                    if (shouldScroll && hashRegex.test(as)) {\n                        _this.scrollToHash(as);\n                    }\n                }\n                return true;\n            } catch (err1) {\n                if ((0, _isError).default(err1) && err1.cancelled) {\n                    return false;\n                }\n                throw err1;\n            }\n        })();\n    }\n    changeState(method, url, as, options = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            console.error(err);\n            if (err.cancelled) {\n                // bubble up cancellation errors\n                throw err;\n            }\n            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                Router.events.emit('routeChangeError', err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n            }\n            try {\n                let props;\n                const { page: Component , styleSheets  } = yield _this.fetchComponent('/_error');\n                const routeInfo = {\n                    props,\n                    Component,\n                    styleSheets,\n                    err,\n                    error: err\n                };\n                if (!routeInfo.props) {\n                    try {\n                        routeInfo.props = yield _this.getInitialProps(Component, {\n                            err,\n                            pathname,\n                            query\n                        });\n                    } catch (gipErr) {\n                        console.error('Error in error page `getInitialProps`: ', gipErr);\n                        routeInfo.props = {};\n                    }\n                }\n                return routeInfo;\n            } catch (routeInfoErr) {\n                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n            }\n        })();\n    }\n    getRouteInfo({ route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache  }) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n            try {\n                var ref, ref4, ref5;\n                const handleCancelled = getCancelledHandler({\n                    route,\n                    router: _this\n                });\n                let existingInfo = _this.components[route];\n                if (routeProps.shallow && existingInfo && _this.route === route) {\n                    return existingInfo;\n                }\n                if (hasMiddleware) {\n                    existingInfo = undefined;\n                }\n                let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n                const fetchNextDataParams = {\n                    dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                            pathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this.isSsr,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !isPreview,\n                    isPrefetch: false,\n                    unstable_skipClientCache\n                };\n                const data = yield withMiddlewareEffects({\n                    fetchData: ()=>fetchNextData(fetchNextDataParams),\n                    asPath: resolvedAs,\n                    locale: locale,\n                    router: _this\n                });\n                handleCancelled();\n                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === 'redirect-external') {\n                    return data.effect;\n                }\n                if ((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === 'rewrite') {\n                    route = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                    pathname = data.effect.resolvedHref;\n                    query = _extends({}, query, data.effect.parsedAs.query);\n                    resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = _this.components[route];\n                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return _extends({}, existingInfo, {\n                            route\n                        });\n                    }\n                }\n                if (route === '/api' || route.startsWith('/api/')) {\n                    handleHardNavigation({\n                        url: as,\n                        router: _this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({\n                        Component: res.page,\n                        styleSheets: res.styleSheets,\n                        __N_SSG: res.mod.__N_SSG,\n                        __N_SSP: res.mod.__N_SSP,\n                        __N_RSC: !!res.mod.__next_rsc__\n                    })));\n                if (process.env.NODE_ENV !== 'production') {\n                    const { isValidElementType  } = require('next/dist/compiled/react-is');\n                    if (!isValidElementType(routeInfo.Component)) {\n                        throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                    }\n                }\n                /**\n       * For server components, non-SSR pages will have statically optimized\n       * flight data in a production build. So only development and SSR pages\n       * will always have the real-time generated and streamed flight data.\n       */ const useStreamedFlightData = routeInfo.__N_RSC && (process.env.NODE_ENV !== 'production' || routeInfo.__N_SSP);\n                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP || routeInfo.__N_RSC;\n                const { props  } = yield _this._getData(_async_to_generator(function*() {\n                    if (shouldFetchData && !useStreamedFlightData) {\n                        const { json  } = (data == null ? void 0 : data.json) ? data : yield fetchNextData({\n                            dataHref: _this.pageLoader.getDataHref({\n                                href: (0, _formatUrl).formatWithValidation({\n                                    pathname,\n                                    query\n                                }),\n                                asPath: resolvedAs,\n                                locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache\n                        });\n                        return {\n                            props: json || {}\n                        };\n                    }\n                    return {\n                        headers: {},\n                        props: yield _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                        {\n                            pathname,\n                            query,\n                            asPath: as,\n                            locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                        })\n                    };\n                }));\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                    const cacheKey = new URL(fetchNextDataParams.dataHref, window.location.href).href;\n                    delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development') {\n                    fetchNextData(Object.assign({}, fetchNextDataParams, {\n                        isBackground: true,\n                        persistCache: false,\n                        inflightCache: backgroundCache\n                    })).catch(()=>{});\n                }\n                let flightInfo;\n                if (routeInfo.__N_RSC) {\n                    flightInfo = {\n                        __flight__: useStreamedFlightData ? (yield _this._getData(()=>_this._getFlightData((0, _formatUrl).formatWithValidation({\n                                query: _extends({}, query, {\n                                    __flight__: '1'\n                                }),\n                                pathname: (0, _isDynamic).isDynamicRoute(route) ? interpolateAs(pathname, (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs).pathname, query).result : pathname\n                            })))).data : props.__flight__\n                    };\n                }\n                props.pageProps = Object.assign({}, props.pageProps, flightInfo);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return routeInfo;\n            } catch (err) {\n                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n            }\n        })();\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            window.scrollTo(0, 0);\n            return;\n        }\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash);\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash);\n        if (idEl) {\n            idEl.scrollIntoView();\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0];\n        if (nameEl) {\n            nameEl.scrollIntoView();\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ prefetch(url, asPath = url, options = {}) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (options.locale === false) {\n                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                    const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                    parsedAs.pathname = localePathResult.pathname;\n                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;\n                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n                }\n            }\n            const pages = yield _this.pageLoader.getPageList();\n            let resolvedAs = asPath;\n            const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n                let rewrites;\n                ({ __rewrites: rewrites  } = yield (0, _routeLoader).getClientBuildManifest());\n                const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                if (rewritesResult.externalDest) {\n                    return;\n                }\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = pathname;\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formatUrl).formatWithValidation(parsed);\n                    }\n                }\n            }\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            }\n            // Prefetch is not supported in development mode because it would trigger on-demand-entries\n            if (process.env.NODE_ENV !== 'production') {\n                return;\n            }\n            // TODO: if the route middleware's data request\n            // resolves to is not an SSG route we should bust the cache\n            // but we shouldn't allow prefetch to keep triggering\n            // requests for SSP pages\n            const data = yield withMiddlewareEffects({\n                fetchData: ()=>fetchNextData({\n                        dataHref: _this.pageLoader.getDataHref({\n                            href: (0, _formatUrl).formatWithValidation({\n                                pathname,\n                                query\n                            }),\n                            skipInterpolation: true,\n                            asPath: resolvedAs,\n                            locale\n                        }),\n                        hasMiddleware: true,\n                        isServerRender: _this.isSsr,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true\n                    }),\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n                parsed.pathname = data.effect.resolvedHref;\n                pathname = data.effect.resolvedHref;\n                query = _extends({}, query, data.effect.parsedAs.query);\n                resolvedAs = data.effect.parsedAs.pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n            /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {\n                return;\n            }\n            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            yield Promise.all([\n                _this.pageLoader._isSsg(route).then((isSsg)=>{\n                    return isSsg ? fetchNextData({\n                        dataHref: (data == null ? void 0 : data.dataHref) || _this.pageLoader.getDataHref({\n                            href: url,\n                            asPath: resolvedAs,\n                            locale: locale\n                        }),\n                        isServerRender: false,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true,\n                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                    }).then(()=>false) : false;\n                }),\n                _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n            ]);\n        })();\n    }\n    fetchComponent(route) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: _this\n            });\n            try {\n                const componentResult = yield _this.pageLoader.loadPage(route);\n                handleCancelled();\n                return componentResult;\n            } catch (err) {\n                handleCancelled();\n                throw err;\n            }\n        })();\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then(({ text  })=>({\n                data: text\n            }));\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview , isRsc  }){\n        // Server Data Cache\n        this.sdc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent  } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , key  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._key !== key) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch (e) {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + key);\n                            forcedScroll = JSON.parse(v);\n                        } catch (e1) {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._key = key;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname === (0, _addBasePath).addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!isRsc\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as1 !== pathname1;\n                    this.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n}\nRouter.events = (0, _mitt).default();\nfunction matchesMiddleware(options) {\n    return Promise.resolve(options.router.pageLoader.getMiddleware()).then((middleware)=>{\n        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);\n        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n        const regex = middleware == null ? void 0 : middleware.location;\n        return !!regex && new RegExp(regex).test((0, _addLocale).addLocale(cleanedAs, options.locale));\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return matchesMiddleware(options).then((matches)=>{\n        if (matches && options.fetchData) {\n            return options.fetchData().then((data)=>getMiddlewareData(data.dataHref, data.response, options).then((effect)=>({\n                        dataHref: data.dataHref,\n                        json: data.json,\n                        response: data.response,\n                        text: data.text,\n                        effect\n                    }))).catch((_err)=>{\n                /**\n           * TODO: Revisit this in the future.\n           * For now we will not consider middleware data errors to be fatal.\n           * maybe we should revisit in the future.\n           */ return null;\n            });\n        }\n        return null;\n    });\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get('x-matched-path');\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/')) {\n            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(), \n            ]).then(([pages, { __rewrites: rewrites  }])=>{\n                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (process.env.__NEXT_HAS_REWRITES) {\n                    const result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsePath).parsePath(source);\n        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        }));\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsePath).parsePath(redirectTarget);\n            const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n                nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            }));\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nexports.default = Router;\n\n//# sourceMappingURL=router.js.map"]},"metadata":{},"sourceType":"script"}