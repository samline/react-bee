{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getMiddlewareRegex = getMiddlewareRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\n\nfunction getRouteRegex(normalizedRoute) {\n  var _getParametrizedRoute = getParametrizedRoute(normalizedRoute),\n      parameterizedRoute = _getParametrizedRoute.parameterizedRoute,\n      groups = _getParametrizedRoute.groups;\n\n  return {\n    re: new RegExp(\"^\".concat(parameterizedRoute, \"(?:/)?$\")),\n    groups: groups\n  };\n}\n\nfunction getNamedRouteRegex(normalizedRoute) {\n  var result = getNamedParametrizedRoute(normalizedRoute);\n  return _extends({}, getRouteRegex(normalizedRoute), {\n    namedRegex: \"^\".concat(result.namedParameterizedRoute, \"(?:/)?$\"),\n    routeKeys: result.routeKeys\n  });\n}\n\nfunction getParametrizedRoute(route) {\n  var segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  var groups = {};\n  var groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter = parseParameter(segment.slice(1, -1)),\n            key = _parseParameter.key,\n            optional = _parseParameter.optional,\n            repeat = _parseParameter.repeat;\n\n        groups[key] = {\n          pos: groupIndex++,\n          repeat: repeat,\n          optional: optional\n        };\n        return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      } else {\n        return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n      }\n    }).join(''),\n    groups: groups\n  };\n}\n\nfunction getNamedParametrizedRoute(route) {\n  var segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  var getSafeRouteKey = buildGetSafeRouteKey();\n  var routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter2 = parseParameter(segment.slice(1, -1)),\n            key = _parseParameter2.key,\n            optional = _parseParameter2.optional,\n            repeat = _parseParameter2.repeat; // replace any non-word characters since they can break\n        // the named regex\n\n\n        var cleanedKey = key.replace(/\\W/g, '');\n        var invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? \"(?:/(?<\".concat(cleanedKey, \">.+?))?\") : \"/(?<\".concat(cleanedKey, \">.+?)\") : \"/(?<\".concat(cleanedKey, \">[^/]+?)\");\n      } else {\n        return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n      }\n    }).join(''),\n    routeKeys: routeKeys\n  };\n}\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */\n\n\nfunction parseParameter(param) {\n  var optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  var repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat: repeat,\n    optional: optional\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\n\n\nfunction buildGetSafeRouteKey() {\n  var routeKeyCharCode = 97;\n  var routeKeyCharLength = 1;\n  return function () {\n    var routeKey = '';\n\n    for (var i = 0; i < routeKeyCharLength; i++) {\n      routeKey += String.fromCharCode(routeKeyCharCode);\n      routeKeyCharCode++;\n\n      if (routeKeyCharCode > 122) {\n        routeKeyCharLength++;\n        routeKeyCharCode = 97;\n      }\n    }\n\n    return routeKey;\n  };\n}\n\nfunction getMiddlewareRegex(normalizedRoute, options) {\n  var _getParametrizedRoute2 = getParametrizedRoute(normalizedRoute),\n      parameterizedRoute = _getParametrizedRoute2.parameterizedRoute,\n      groups = _getParametrizedRoute2.groups;\n\n  var _ref = options != null ? options : {},\n      _ref$catchAll = _ref.catchAll,\n      catchAll = _ref$catchAll === void 0 ? true : _ref$catchAll;\n\n  if (parameterizedRoute === '/') {\n    var catchAllRegex = catchAll ? '.*' : '';\n    return {\n      groups: {},\n      re: new RegExp(\"^/\".concat(catchAllRegex, \"$\"))\n    };\n  }\n\n  var catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    groups: groups,\n    re: new RegExp(\"^\".concat(parameterizedRoute).concat(catchAllGroupedRegex, \"$\"))\n  };\n}\n\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  var _getParametrizedRoute3 = getParametrizedRoute(normalizedRoute),\n      parameterizedRoute = _getParametrizedRoute3.parameterizedRoute;\n\n  var _options$catchAll = options.catchAll,\n      catchAll = _options$catchAll === void 0 ? true : _options$catchAll;\n\n  if (parameterizedRoute === '/') {\n    var catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: \"^/\".concat(catchAllRegex, \"$\")\n    };\n  }\n\n  var _getNamedParametrized = getNamedParametrizedRoute(normalizedRoute),\n      namedParameterizedRoute = _getNamedParametrized.namedParameterizedRoute;\n\n  var catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: \"^\".concat(namedParameterizedRoute).concat(catchAllGroupedRegex, \"$\")\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/route-regex.ts"],"names":["getRouteRegex","normalizedRoute","parameterizedRoute","groups","getParametrizedRoute","re","RegExp","getNamedRouteRegex","result","getNamedParametrizedRoute","namedRegex","namedParameterizedRoute","routeKeys","route","segments","removeTrailingSlash","slice","split","groupIndex","map","segment","startsWith","endsWith","key","optional","repeat","parseParameter","pos","escapeStringRegexp","join","getSafeRouteKey","buildGetSafeRouteKey","cleanedKey","replace","invalidKey","length","isNaN","parseInt","param","routeKeyCharCode","routeKeyCharLength","routeKey","i","String","fromCharCode","getMiddlewareRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex","getNamedMiddlewareRegex"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getMiddlewareRegex = getMiddlewareRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n        groups: groups\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute) {\n    const result = getNamedParametrizedRoute(normalizedRoute);\n    return _extends({}, getRouteRegex(normalizedRoute), {\n        namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n        routeKeys: result.routeKeys\n    });\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        groups\n    };\n}\nfunction getNamedParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, '');\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        routeKeys\n    };\n}\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1;\n    return ()=>{\n        let routeKey = '';\n        for(let i = 0; i < routeKeyCharLength; i++){\n            routeKey += String.fromCharCode(routeKeyCharCode);\n            routeKeyCharCode++;\n            if (routeKeyCharCode > 122) {\n                routeKeyCharLength++;\n                routeKeyCharCode = 97;\n            }\n        }\n        return routeKey;\n    };\n}\nfunction getMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);\n    const { catchAll =true  } = options != null ? options : {};\n    if (parameterizedRoute === '/') {\n        let catchAllRegex = catchAll ? '.*' : '';\n        return {\n            groups: {},\n            re: new RegExp(`^/${catchAllRegex}$`)\n        };\n    }\n    let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n    return {\n        groups: groups,\n        re: new RegExp(`^${parameterizedRoute}${catchAllGroupedRegex}$`)\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute  } = getParametrizedRoute(normalizedRoute);\n    const { catchAll =true  } = options;\n    if (parameterizedRoute === '/') {\n        let catchAllRegex = catchAll ? '.*' : '';\n        return {\n            namedRegex: `^/${catchAllRegex}$`\n        };\n    }\n    const { namedParameterizedRoute  } = getNamedParametrizedRoute(normalizedRoute);\n    let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n    return {\n        namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`\n    };\n}\n\n//# sourceMappingURL=route-regex.js.map"]},"metadata":{},"sourceType":"script"}