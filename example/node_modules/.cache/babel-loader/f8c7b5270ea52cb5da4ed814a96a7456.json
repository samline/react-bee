{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */\nfunction parseParameter(param) {\n  var optional = param.startsWith('[') && param.endsWith(']');\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  var repeat = param.startsWith('...');\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat: repeat,\n    optional: optional\n  };\n}\nfunction getParametrizedRoute(route) {\n  var segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  var groups = {};\n  var groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter = parseParameter(segment.slice(1, -1)),\n          key = _parseParameter.key,\n          optional = _parseParameter.optional,\n          repeat = _parseParameter.repeat;\n        groups[key] = {\n          pos: groupIndex++,\n          repeat: repeat,\n          optional: optional\n        };\n        return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      } else {\n        return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n      }\n    }).join(''),\n    groups: groups\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  var _getParametrizedRoute = getParametrizedRoute(normalizedRoute),\n    parameterizedRoute = _getParametrizedRoute.parameterizedRoute,\n    groups = _getParametrizedRoute.groups;\n  return {\n    re: new RegExp(\"^\".concat(parameterizedRoute, \"(?:/)?$\")),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  var routeKeyCharCode = 97;\n  var routeKeyCharLength = 1;\n  return function () {\n    var routeKey = '';\n    for (var i = 0; i < routeKeyCharLength; i++) {\n      routeKey += String.fromCharCode(routeKeyCharCode);\n      routeKeyCharCode++;\n      if (routeKeyCharCode > 122) {\n        routeKeyCharLength++;\n        routeKeyCharCode = 97;\n      }\n    }\n    return routeKey;\n  };\n}\nfunction getNamedParametrizedRoute(route) {\n  var segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n  var getSafeRouteKey = buildGetSafeRouteKey();\n  var routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter2 = parseParameter(segment.slice(1, -1)),\n          key = _parseParameter2.key,\n          optional = _parseParameter2.optional,\n          repeat = _parseParameter2.repeat;\n        // replace any non-word characters since they can break\n        // the named regex\n        var cleanedKey = key.replace(/\\W/g, '');\n        var invalidKey = false;\n        // check if the key is still invalid and fallback to using a known\n        // safe key\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n          invalidKey = true;\n        }\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? \"(?:/(?<\".concat(cleanedKey, \">.+?))?\") : \"/(?<\".concat(cleanedKey, \">.+?)\") : \"/(?<\".concat(cleanedKey, \">[^/]+?)\");\n      } else {\n        return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n      }\n    }).join(''),\n    routeKeys: routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute) {\n  var result = getNamedParametrizedRoute(normalizedRoute);\n  return _extends({}, getRouteRegex(normalizedRoute), {\n    namedRegex: \"^\".concat(result.namedParameterizedRoute, \"(?:/)?$\"),\n    routeKeys: result.routeKeys\n  });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  var _getParametrizedRoute2 = getParametrizedRoute(normalizedRoute),\n    parameterizedRoute = _getParametrizedRoute2.parameterizedRoute;\n  var _options$catchAll = options.catchAll,\n    catchAll = _options$catchAll === void 0 ? true : _options$catchAll;\n  if (parameterizedRoute === '/') {\n    var catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: \"^/\".concat(catchAllRegex, \"$\")\n    };\n  }\n  var _getNamedParametrized = getNamedParametrizedRoute(normalizedRoute),\n    namedParameterizedRoute = _getNamedParametrized.namedParameterizedRoute;\n  var catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: \"^\".concat(namedParameterizedRoute).concat(catchAllGroupedRegex, \"$\")\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/route-regex.ts"],"names":["parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","pos","escapeStringRegexp","join","getRouteRegex","normalizedRoute","re","RegExp","buildGetSafeRouteKey","routeKeyCharCode","routeKeyCharLength","routeKey","i","String","fromCharCode","getNamedParametrizedRoute","getSafeRouteKey","routeKeys","namedParameterizedRoute","cleanedKey","replace","invalidKey","length","isNaN","parseInt","getNamedRouteRegex","result","namedRegex","getNamedMiddlewareRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1;\n    return ()=>{\n        let routeKey = '';\n        for(let i = 0; i < routeKeyCharLength; i++){\n            routeKey += String.fromCharCode(routeKeyCharCode);\n            routeKeyCharCode++;\n            if (routeKeyCharCode > 122) {\n                routeKeyCharLength++;\n                routeKeyCharCode = 97;\n            }\n        }\n        return routeKey;\n    };\n}\nfunction getNamedParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, '');\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute) {\n    const result = getNamedParametrizedRoute(normalizedRoute);\n    return _extends({}, getRouteRegex(normalizedRoute), {\n        namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n        routeKeys: result.routeKeys\n    });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute  } = getParametrizedRoute(normalizedRoute);\n    const { catchAll =true  } = options;\n    if (parameterizedRoute === '/') {\n        let catchAllRegex = catchAll ? '.*' : '';\n        return {\n            namedRegex: `^/${catchAllRegex}$`\n        };\n    }\n    const { namedParameterizedRoute  } = getNamedParametrizedRoute(normalizedRoute);\n    let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n    return {\n        namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`\n    };\n}\n\n//# sourceMappingURL=route-regex.js.map"]},"metadata":{},"sourceType":"script"}