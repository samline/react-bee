{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathMatch = getPathMatch;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n  var keys = [];\n  var regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n    delimiter: '/',\n    sensitive: false,\n    strict: options == null ? void 0 : options.strict\n  });\n  var matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n  return function (pathname, params) {\n    var res = pathname == null ? false : matcher(pathname);\n    if (!res) {\n      return false;\n    }\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n    if (options == null ? void 0 : options.removeUnnamedParams) {\n      var _iterator = _createForOfIteratorHelper(keys),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          if (typeof key.name === 'number') {\n            delete res.params[key.name];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return _extends({}, params, res.params);\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/path-match.ts"],"names":["getPathMatch","path","options","keys","regexp","pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","res","removeUnnamedParams","key","name"],"mappings":"AAAA,YAAA;;AAAA;;;;QA2BgBA,YAAY,GAAZA,YAAY;;AA1BC,IAAA,aAAmC,GAAA,OAAA,CAAnC,mCAAmC,CAAA;AA0BzD,SAASA,YAAY,CAACC,IAAY,EAAEC,OAAiB,EAAE;EAC5D,IAAMC,IAAI,GAAU,EAAE;EACtB,IAAMC,MAAM,GAAGC,CAAAA,CAAAA,EAAAA,aAIb,EAAA,YAJyB,CAACJ,IAAI,EAAEE,IAAI,EAAE;IACtCG,SAAS,EAAE,GAAG;IACdC,SAAS,EAAE,KAAK;IAChBC,MAAM,EAAEN,OAAO,IAAA,IAAQ,GAAfA,KAAAA,CAAe,GAAfA,OAAO,CAAEM;GAClB,CAAC;EAEF,IAAMC,OAAO,GAAGC,CAAAA,CAAAA,EAAAA,aAKf,EAAA,gBAL+B,CAC9BR,CAAAA,OAAO,IAAA,IAAe,GAAtBA,KAAAA,CAAsB,GAAtBA,OAAO,CAAES,aAAa,IAClB,IAAIC,MAAM,CAACV,OAAO,CAACS,aAAa,CAACP,MAAM,CAACS,MAAM,CAAC,EAAET,MAAM,CAACU,KAAK,CAAC,GAC9DV,MAAM,EACVD,IAAI,CACL;EAED;;;;;AAKG;EACH,OAAO,UACLY,QAAwB,EACxBC,MAAY,EACE;IACd,IAAMC,GAAG,GAAGF,QAAQ,IAAI,IAAI,GAAG,KAAK,GAAGN,OAAO,CAACM,QAAQ,CAAC;IACxD,IAAI,CAACE,GAAG,EAAE;MACR,OAAO,KAAK;IACb;IAED;;;;AAIG;IACH,IAAIf,OAAO,IAAA,IAAqB,GAA5BA,KAAAA,CAA4B,GAA5BA,OAAO,CAAEgB,mBAAmB,EAAE;MAAA,2CACdf,IAAI;QAAA;MAAA;QAAtB,oDAAwB;UAAA,IAAbgB,GAAG;UACZ,IAAI,OAAOA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;YAChC,OAAQH,GAAG,CAACD,MAAc,CAACG,GAAG,CAACC,IAAI,CAAC;UACrC;;MACF;QAAA;MAAA;QAAA;MAAA;IACF;IAED,OAAO,QAAA,CAAA,CAAA,CAAA,EAAKJ,MAAM,EAAKC,GAAG,CAACD,MAAM,CAAE;GACpC;AACF","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getPathMatch = getPathMatch;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n    const keys = [];\n    const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n        delimiter: '/',\n        sensitive: false,\n        strict: options == null ? void 0 : options.strict\n    });\n    const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n    /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */ return (pathname, params)=>{\n        const res = pathname == null ? false : matcher(pathname);\n        if (!res) {\n            return false;\n        }\n        /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */ if (options == null ? void 0 : options.removeUnnamedParams) {\n            for (const key of keys){\n                if (typeof key.name === 'number') {\n                    delete res.params[key.name];\n                }\n            }\n        }\n        return _extends({}, params, res.params);\n    };\n}\n\n//# sourceMappingURL=path-match.js.map"]},"metadata":{},"sourceType":"script"}