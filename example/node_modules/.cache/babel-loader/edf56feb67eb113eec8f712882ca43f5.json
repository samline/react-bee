{"ast":null,"code":"\"client\";\n\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports.default = void 0;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _react = _interop_require_wildcard(require(\"react\"));\nvar _headManagerContext = require(\"../shared/lib/head-manager-context\");\nvar _headManager = require(\"./head-manager\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n'client';\nvar ScriptCache = new Map();\nvar LoadCache = new Set();\nvar ignoreProps = ['onLoad', 'onReady', 'dangerouslySetInnerHTML', 'children', 'onError', 'strategy'];\nvar loadScript = function loadScript(props) {\n  var src = props.src,\n    id = props.id,\n    _props$onLoad = props.onLoad,\n    onLoad = _props$onLoad === void 0 ? function () {} : _props$onLoad,\n    _props$onReady = props.onReady,\n    onReady = _props$onReady === void 0 ? null : _props$onReady,\n    dangerouslySetInnerHTML = props.dangerouslySetInnerHTML,\n    _props$children = props.children,\n    children = _props$children === void 0 ? '' : _props$children,\n    _props$strategy = props.strategy,\n    strategy = _props$strategy === void 0 ? 'afterInteractive' : _props$strategy,\n    onError = props.onError;\n  var cacheKey = id || src;\n  // Script has already loaded\n  if (cacheKey && LoadCache.has(cacheKey)) {\n    return;\n  }\n  // Contents of this script are already loading/loaded\n  if (ScriptCache.has(src)) {\n    LoadCache.add(cacheKey);\n    // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n    // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n    ScriptCache.get(src).then(onLoad, onError);\n    return;\n  }\n  /** Execute after the script first loaded */\n  var afterLoad = function afterLoad() {\n    // Run onReady for the first time after load event\n    if (onReady) {\n      onReady();\n    }\n    // add cacheKey to LoadCache when load successfully\n    LoadCache.add(cacheKey);\n  };\n  var el = document.createElement('script');\n  var loadPromise = new Promise(function (resolve, reject) {\n    el.addEventListener('load', function (e) {\n      resolve();\n      if (onLoad) {\n        onLoad.call(this, e);\n      }\n      afterLoad();\n    });\n    el.addEventListener('error', function (e) {\n      reject(e);\n    });\n  }).catch(function (e) {\n    if (onError) {\n      onError(e);\n    }\n  });\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || '';\n    afterLoad();\n  } else if (children) {\n    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n    afterLoad();\n  } else if (src) {\n    el.src = src;\n    // do not add cacheKey into LoadCache for remote script here\n    // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n    ScriptCache.set(src, loadPromise);\n  }\n  for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      k = _Object$entries$_i[0],\n      value = _Object$entries$_i[1];\n    if (value === undefined || ignoreProps.includes(k)) {\n      continue;\n    }\n    var attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n    el.setAttribute(attr, value);\n  }\n  if (strategy === 'worker') {\n    el.setAttribute('type', 'text/partytown');\n  }\n  el.setAttribute('data-nscript', strategy);\n  document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n  var _props$strategy2 = props.strategy,\n    strategy = _props$strategy2 === void 0 ? 'afterInteractive' : _props$strategy2;\n  if (strategy === 'lazyOnload') {\n    window.addEventListener('load', function () {\n      (0, _requestIdleCallback).requestIdleCallback(function () {\n        return loadScript(props);\n      });\n    });\n  } else {\n    loadScript(props);\n  }\n}\nfunction loadLazyScript(props) {\n  if (document.readyState === 'complete') {\n    (0, _requestIdleCallback).requestIdleCallback(function () {\n      return loadScript(props);\n    });\n  } else {\n    window.addEventListener('load', function () {\n      (0, _requestIdleCallback).requestIdleCallback(function () {\n        return loadScript(props);\n      });\n    });\n  }\n}\nfunction addBeforeInteractiveToCache() {\n  var scripts = [].concat(_toConsumableArray(document.querySelectorAll('[data-nscript=\"beforeInteractive\"]')), _toConsumableArray(document.querySelectorAll('[data-nscript=\"beforePageRender\"]')));\n  scripts.forEach(function (script) {\n    var cacheKey = script.id || script.getAttribute('src');\n    LoadCache.add(cacheKey);\n  });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n  scriptLoaderItems.forEach(handleClientScriptLoad);\n  addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n  var id = props.id,\n    _props$src = props.src,\n    src = _props$src === void 0 ? '' : _props$src,\n    _props$onLoad2 = props.onLoad,\n    onLoad = _props$onLoad2 === void 0 ? function () {} : _props$onLoad2,\n    _props$onReady2 = props.onReady,\n    onReady = _props$onReady2 === void 0 ? null : _props$onReady2,\n    _props$strategy3 = props.strategy,\n    strategy = _props$strategy3 === void 0 ? 'afterInteractive' : _props$strategy3,\n    onError = props.onError,\n    restProps = _object_without_properties_loose(props, [\"id\", \"src\", \"onLoad\", \"onReady\", \"strategy\", \"onError\"]);\n  // Context is available only during SSR\n  var _useContext = (0, _react).useContext(_headManagerContext.HeadManagerContext),\n    updateScripts = _useContext.updateScripts,\n    scripts = _useContext.scripts,\n    getIsSsr = _useContext.getIsSsr;\n  /**\n  * - First mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n  *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n  *      Once the script is loaded, the onLoad and onReady will be called by then\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  *\n  * - Second mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n  *      onReady is called, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. The script is already loaded, loadScript bails out\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  */\n  var hasOnReadyEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(function () {\n    var cacheKey = id || src;\n    if (!hasOnReadyEffectCalled.current) {\n      // Run onReady if script has loaded before but component is re-mounted\n      if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n        onReady();\n      }\n      hasOnReadyEffectCalled.current = true;\n    }\n  }, [onReady, id, src]);\n  var hasLoadScriptEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(function () {\n    if (!hasLoadScriptEffectCalled.current) {\n      if (strategy === 'afterInteractive') {\n        loadScript(props);\n      } else if (strategy === 'lazyOnload') {\n        loadLazyScript(props);\n      }\n      hasLoadScriptEffectCalled.current = true;\n    }\n  }, [props, strategy]);\n  if (strategy === 'beforeInteractive' || strategy === 'worker') {\n    if (updateScripts) {\n      scripts[strategy] = (scripts[strategy] || []).concat([_extends({\n        id: id,\n        src: src,\n        onLoad: onLoad,\n        onReady: onReady,\n        onError: onError\n      }, restProps)]);\n      updateScripts(scripts);\n    } else if (getIsSsr && getIsSsr()) {\n      // Script has already loaded during SSR\n      LoadCache.add(id || src);\n    } else if (getIsSsr && !getIsSsr()) {\n      loadScript(props);\n    }\n  }\n  return null;\n}\nObject.defineProperty(Script, '__nextScript', {\n  value: true\n});\nvar _default = Script;\nexports.default = _default;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"sources":["../../client/script.tsx"],"names":["ScriptCache","LoadCache","Set","ignoreProps","id","onLoad","cacheKey","src","add","onReady","loadPromise","resolve","reject","el","addEventListener","call","afterLoad","catch","onError","dangerouslySetInnerHTML","children","textContent","value","undefined","includes","setAttribute","document","appendChild","handleClientScriptLoad","strategy","window","requestIdleCallback","loadScript","readyState","querySelectorAll","scripts","script","initScriptLoader","scriptLoaderItems","forEach","addBeforeInteractiveToCache","useEffect","hasOnReadyEffectCalled","hasLoadScriptEffectCalled","props","loadLazyScript","updateScripts","restProps","getIsSsr","Object","Script"],"mappings":"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","sourcesContent":["\"client\";\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports.default = void 0;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _react = _interop_require_wildcard(require(\"react\"));\nvar _headManagerContext = require(\"../shared/lib/head-manager-context\");\nvar _headManager = require(\"./head-manager\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n'client';\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy', \n];\nconst loadScript = (props)=>{\n    const { src , id , onLoad =()=>{} , onReady =null , dangerouslySetInnerHTML , children ='' , strategy ='afterInteractive' , onError ,  } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement('script');\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener('load', function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener('error', function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || '';\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === 'worker') {\n        el.setAttribute('type', 'text/partytown');\n    }\n    el.setAttribute('data-nscript', strategy);\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy ='afterInteractive'  } = props;\n    if (strategy === 'lazyOnload') {\n        window.addEventListener('load', ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === 'complete') {\n        (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n    } else {\n        window.addEventListener('load', ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]'), \n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute('src');\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    const { id , src ='' , onLoad =()=>{} , onReady =null , strategy ='afterInteractive' , onError  } = props, restProps = _object_without_properties_loose(props, [\n        \"id\",\n        \"src\",\n        \"onLoad\",\n        \"onReady\",\n        \"strategy\",\n        \"onError\"\n    ]);\n    // Context is available only during SSR\n    const { updateScripts , scripts , getIsSsr  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === 'afterInteractive') {\n                loadScript(props);\n            } else if (strategy === 'lazyOnload') {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === 'beforeInteractive' || strategy === 'worker') {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                _extends({\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError\n                }, restProps), \n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    return null;\n}\nObject.defineProperty(Script, '__nextScript', {\n    value: true\n});\nvar _default = Script;\nexports.default = _default;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=script.js.map"]},"metadata":{},"sourceType":"script"}