{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _slicedToArray = require(\"/Users/sam/Documents/sites/react-bee/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesMiddleware = matchesMiddleware;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports.default = void 0;\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _removeTrailingSlash = require(\"./utils/remove-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _script = require(\"../../../client/script\");\nvar _isError = _interop_require_wildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interop_require_default(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interop_require_default(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _formatUrl = require(\"./utils/format-url\");\nvar _detectDomainLocale = require(\"../../../client/detect-domain-locale\");\nvar _parsePath = require(\"./utils/parse-path\");\nvar _addLocale = require(\"../../../client/add-locale\");\nvar _removeLocale = require(\"../../../client/remove-locale\");\nvar _removeBasePath = require(\"../../../client/remove-base-path\");\nvar _addBasePath = require(\"../../../client/add-base-path\");\nvar _hasBasePath = require(\"../../../client/has-base-path\");\nvar _getNextPathnameInfo = require(\"./utils/get-next-pathname-info\");\nvar _formatNextPathnameInfo = require(\"./utils/format-next-pathname-info\");\nvar _compareStates = require(\"./utils/compare-states\");\nvar _isBot = require(\"./utils/is-bot\");\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\nfunction matchesMiddleware(options) {\n  return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n  _matchesMiddleware = _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n    var matchers, _parsePath2, asPathname, cleanedAs, asWithBasePathAndLocale;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n          case 2:\n            matchers = _context.sent;\n            if (matchers) {\n              _context.next = 5;\n              break;\n            }\n            return _context.abrupt(\"return\", false);\n          case 5:\n            _parsePath2 = (0, _parsePath).parsePath(options.asPath), asPathname = _parsePath2.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n            cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n            return _context.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n  var origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction omit(object, keys) {\n  var omitted = {};\n  Object.keys(object).forEach(function (key) {\n    if (!keys.includes(key)) {\n      omitted[key] = object[key];\n    }\n  });\n  return omitted;\n}\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!(0, _utils).isAbsoluteUrl(url)) return true;\n  try {\n    // absolute urls can be local if they are on the same origin\n    var locationOrigin = (0, _utils).getLocationOrigin();\n    var resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\nfunction interpolateAs(route, asPathname, query) {\n  var interpolatedRoute = '';\n  var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  var dynamicGroups = dynamicRegex.groups;\n  var dynamicMatches =\n  // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') ||\n  // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  var params = Object.keys(dynamicGroups);\n  if (!params.every(function (param) {\n    var value = dynamicMatches[param] || '';\n    var _dynamicGroups$param = dynamicGroups[param],\n      repeat = _dynamicGroups$param.repeat,\n      optional = _dynamicGroups$param.optional;\n    // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n    var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n    if (optional) {\n      replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n    }\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (\n    // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(\n    // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    function (segment) {\n      return encodeURIComponent(segment);\n    }).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params: params,\n    result: interpolatedRoute\n  };\n}\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  var base;\n  var urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  var urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  var urlParts = urlAsStringNoProto.split('?');\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n    var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  }\n  // Return because it cannot be routed by the Next.js router\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n  try {\n    var finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    var interpolatedAs = '';\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),\n        result = _interpolateAs.result,\n        params = _interpolateAs.params;\n      if (result) {\n        interpolatedAs = (0, _formatUrl).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omit(query, params)\n        });\n      }\n    }\n    // if the origin didn't change, it means we received a relative href\n    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _resolveHref = resolveHref(router, url, true),\n    _resolveHref2 = _slicedToArray(_resolveHref, 2),\n    resolvedHref = _resolveHref2[0],\n    resolvedAs = _resolveHref2[1];\n  var origin = (0, _utils).getLocationOrigin();\n  var hrefHadOrigin = resolvedHref.startsWith(origin);\n  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n  var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n  };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  }\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n  return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n  };\n  var rewriteHeader = response.headers.get('x-nextjs-rewrite');\n  var rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n  var matchedPath = response.headers.get('x-matched-path');\n  if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith('/')) {\n      var parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n      var pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest()]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          pages = _ref2[0],\n          rewrites = _ref2[1].__rewrites;\n        var as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n        if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n        if (process.env.__NEXT_HAS_REWRITES) {\n          var result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, function (path) {\n            return resolveDynamicRoute(path, pages);\n          }, options.router.locales);\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname;\n            as = parsedRewriteTarget.pathname;\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n          }\n        } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n        if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n          var matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n        return {\n          type: 'rewrite',\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n    var src = (0, _parsePath).parsePath(source);\n    var pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    }), {\n      defaultLocale: options.router.defaultLocale,\n      buildId: ''\n    }));\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n    });\n  }\n  var redirectTarget = response.headers.get('x-nextjs-redirect');\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      var _src = (0, _parsePath).parsePath(redirectTarget);\n      var _pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      }), {\n        defaultLocale: options.router.defaultLocale,\n        buildId: ''\n      }));\n      return Promise.resolve({\n        type: 'redirect-internal',\n        newAs: \"\".concat(_pathname).concat(_src.query).concat(_src.hash),\n        newUrl: \"\".concat(_pathname).concat(_src.query).concat(_src.hash)\n      });\n    }\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: redirectTarget\n    });\n  }\n  return Promise.resolve({\n    type: 'next'\n  });\n}\nfunction withMiddlewareEffects(options) {\n  return matchesMiddleware(options).then(function (matches) {\n    if (matches && options.fetchData) {\n      return options.fetchData().then(function (data) {\n        return getMiddlewareData(data.dataHref, data.response, options).then(function (effect) {\n          return {\n            dataHref: data.dataHref,\n            cacheKey: data.cacheKey,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            effect: effect\n          };\n        });\n      }).catch(function (_err) {\n        /**\n        * TODO: Revisit this in the future.\n        * For now we will not consider middleware data errors to be fatal.\n        * maybe we should revisit in the future.\n        */\n        return null;\n      });\n    }\n    return null;\n  });\n}\nvar manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    var v = '__next';\n    // eslint-disable-next-line no-sequences\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1'\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\nvar backgroundCache = {};\nfunction handleSmoothScroll(fn) {\n  var htmlElement = document.documentElement;\n  var existing = htmlElement.style.scrollBehavior;\n  htmlElement.style.scrollBehavior = 'auto';\n  fn();\n  htmlElement.style.scrollBehavior = existing;\n}\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\nfunction fetchNextData(_ref3) {\n  var dataHref = _ref3.dataHref,\n    inflightCache = _ref3.inflightCache,\n    isPrefetch = _ref3.isPrefetch,\n    hasMiddleware = _ref3.hasMiddleware,\n    isServerRender = _ref3.isServerRender,\n    parseJSON = _ref3.parseJSON,\n    persistCache = _ref3.persistCache,\n    isBackground = _ref3.isBackground,\n    unstable_skipClientCache = _ref3.unstable_skipClientCache;\n  var _URL = new URL(dataHref, window.location.href),\n    cacheKey = _URL.href;\n  var ref1;\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: isPrefetch ? {\n        purpose: 'prefetch'\n      } : {},\n      method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: '',\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n          if (!hasMiddleware && response.status === 404) {\n            var ref;\n            if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n          if (!isServerRender) {\n            (0, _routeLoader).markAssetError(error);\n          }\n          throw error;\n        }\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n        delete inflightCache[cacheKey];\n      }\n      return data;\n    }).catch(function (err) {\n      delete inflightCache[cacheKey];\n      throw err;\n    });\n  };\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: 'HEAD'\n  } : {});\n}\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(_ref4) {\n  var url = _ref4.url,\n    router = _ref4.router;\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n  }\n  window.location.href = url;\n}\nvar getCancelledHandler = function getCancelledHandler(_ref5) {\n  var route = _ref5.route,\n    router = _ref5.router;\n  var cancelled = false;\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n  return handleCancelled;\n};\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname1, query1, as1, _ref6) {\n    var _this2 = this;\n    var initialProps = _ref6.initialProps,\n      pageLoader = _ref6.pageLoader,\n      App = _ref6.App,\n      wrapApp = _ref6.wrapApp,\n      Component = _ref6.Component,\n      err = _ref6.err,\n      subscription = _ref6.subscription,\n      isFallback = _ref6.isFallback,\n      locale = _ref6.locale,\n      locales = _ref6.locales,\n      defaultLocale = _ref6.defaultLocale,\n      domainLocales = _ref6.domainLocales,\n      isPreview = _ref6.isPreview;\n    _classCallCheck(this, Router);\n    // Server Data Cache\n    this.sdc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this2.isFirstPopStateEvent;\n      _this2.isFirstPopStateEvent = false;\n      var state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this2.pathname,\n          query = _this2.query;\n        _this2.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n          pathname: (0, _addBasePath).addBasePath(_pathname2),\n          query: query\n        }), (0, _utils).getURL());\n        return;\n      }\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      // Safari fires popstateevent when reopening the browser.\n      if (isFirstPopStateEvent && _this2.locale === state.options.locale && state.as === _this2.asPath) {\n        return;\n      }\n      var forcedScroll;\n      var url = state.url,\n        as = state.as,\n        options = state.options,\n        key = state.key;\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (_this2._key !== key) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + _this2._key, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (e) {}\n            // Restore old scroll position:\n            try {\n              var v = sessionStorage.getItem('__next_scroll_' + key);\n              forcedScroll = JSON.parse(v);\n            } catch (e1) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n      _this2._key = key;\n      var _parseRelativeUrl2 = (0, _parseRelativeUrl).parseRelativeUrl(url),\n        pathname = _parseRelativeUrl2.pathname;\n      // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (_this2.isSsr && as === (0, _addBasePath).addBasePath(_this2.asPath) && pathname === (0, _addBasePath).addBasePath(_this2.pathname)) {\n        return;\n      }\n      // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (_this2._bps && !_this2._bps(state)) {\n        return;\n      }\n      _this2.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this2._shallow,\n        locale: options.locale || _this2.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    };\n    // represents the current component key\n    var route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n    // set up the component cache (by route keys)\n    this.components = {};\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname1 !== '/_error') {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    };\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp;\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);\n    }\n    this.state = {\n      route: route,\n      pathname: pathname1,\n      query: query1,\n      asPath: autoExportDynamic ? pathname1 : as1,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as1.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils).getURL();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as1 !== pathname1;\n          _this2.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({\n            pathname: (0, _addBasePath).addBasePath(pathname1),\n            query: query1\n          }), asPath, options);\n          return matches;\n        });\n      }\n      window.addEventListener('popstate', this.onPopState);\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n  }, {\n    key: \"push\",\n    value: function push(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        // TODO: remove in the future when we update history before route change\n        // is complete, as the popstate event should handle this capture.\n        if (manualScrollRestoration) {\n          try {\n            // Snapshot scroll position right before navigating to a new page:\n            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n              x: self.pageXOffset,\n              y: self.pageYOffset\n            }));\n          } catch (e) {}\n        }\n      }\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change('pushState', url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n  }, {\n    key: \"replace\",\n    value: function replace(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change('replaceState', url, as, options);\n    }\n  }, {\n    key: \"change\",\n    value: function change(method, url, as, options, forcedScroll) {\n      var _this = this;\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, isMiddlewareMatch, rewritesResult, route, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, ref2, ref3, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex2, curRouteMatch, _routeInfo, error, props, __N_SSG, __N_SSP, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _route, isValidShallowRoute, _scroll, shouldScroll, resetScroll, upcomingRouterState, upcomingScrollState, canSkipUpdating, hashRegex;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (isLocalURL(url)) {\n                  _context2.next = 3;\n                  break;\n                }\n                handleHardNavigation({\n                  url: url,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", false);\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h;\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n                nextState = _extends({}, _this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n                readyStateChange = _this.isReady !== true;\n                _this.isReady = true;\n                isSsr = _this.isSsr;\n                if (!isQueryUpdating) {\n                  _this.isSsr = false;\n                }\n                // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n                if (!(isQueryUpdating && _this.clc)) {\n                  _context2.next = 12;\n                  break;\n                }\n                return _context2.abrupt(\"return\", false);\n              case 12:\n                prevLocale = nextState.locale;\n                if (!process.env.__NEXT_I18N_SUPPORT) {\n                  _context2.next = 25;\n                  break;\n                }\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n                if (typeof options.locale === 'undefined') {\n                  options.locale = nextState.locale;\n                }\n                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);\n                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);\n                  as = (0, _formatUrl).formatWithValidation(parsedAs);\n                  url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);\n                }\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  // if the locale isn't configured hard navigate to show 404 page\n                  if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {\n                    parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);\n                    handleHardNavigation({\n                      url: (0, _formatUrl).formatWithValidation(parsedAs),\n                      router: _this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                  }\n                }\n                detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  // if we are navigating to a domain locale ensure we redirect to the\n                  // correct domain\n                  if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    asNoBasePath = (0, _removeBasePath).removeBasePath(as);\n                    handleHardNavigation({\n                      url: \"http\".concat(detectedDomain.http ? '' : 's', \"://\").concat(detectedDomain.domain).concat((0, _addBasePath).addBasePath(\"\".concat(nextState.locale === detectedDomain.defaultLocale ? '' : \"/\".concat(nextState.locale)).concat(asNoBasePath === '/' ? '' : asNoBasePath) || '/')),\n                      router: _this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                  }\n                }\n                if (!didNavigate) {\n                  _context2.next = 25;\n                  break;\n                }\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n              case 25:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark('routeChange');\n                }\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n                if (_this._inFlightRoute && _this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                  }\n                  _this.clc();\n                  _this.clc = null;\n                }\n                as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n                cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n                _this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context2.next = 49;\n                  break;\n                }\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                  scroll: false\n                }));\n                if (scroll) {\n                  _this.scrollToHash(cleanedAs);\n                }\n                _context2.prev = 38;\n                _context2.next = 41;\n                return _this.set(nextState, _this.components[nextState.route], null);\n              case 41:\n                _context2.next = 47;\n                break;\n              case 43:\n                _context2.prev = 43;\n                _context2.t0 = _context2[\"catch\"](38);\n                if ((0, _isError).default(_context2.t0) && _context2.t0.cancelled) {\n                  Router.events.emit('routeChangeError', _context2.t0, cleanedAs, routeProps);\n                }\n                throw _context2.t0;\n              case 47:\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return _context2.abrupt(\"return\", true);\n              case 49:\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages\n                // get their query parameters to allow ensuring they can be parsed properly\n                // when rewritten to\n                _context2.prev = 51;\n                _context2.next = 54;\n                return Promise.all([_this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), _this.pageLoader.getMiddleware()]);\n              case 54:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context2.next = 64;\n                break;\n              case 60:\n                _context2.prev = 60;\n                _context2.t1 = _context2[\"catch\"](51);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", false);\n              case 64:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = 'replaceState';\n                }\n                // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n                pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n                // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n                _context2.next = 69;\n                return matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: _this\n                });\n              case 69:\n                isMiddlewareMatch = _context2.sent;\n                if (options.shallow && isMiddlewareMatch) {\n                  pathname = _this.pathname;\n                }\n                if (!(shouldResolveHref && pathname !== '/_error')) {\n                  _context2.next = 84;\n                  break;\n                }\n                options._shouldResolveHref = true;\n                if (!(process.env.__NEXT_HAS_REWRITES && as.startsWith('/'))) {\n                  _context2.next = 82;\n                  break;\n                }\n                rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n                if (!rewritesResult.externalDest) {\n                  _context2.next = 78;\n                  break;\n                }\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", true);\n              case 78:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                }\n                _context2.next = 84;\n                break;\n              case 82:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                  }\n                }\n              case 84:\n                if (isLocalURL(as)) {\n                  _context2.next = 89;\n                  break;\n                }\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context2.next = 87;\n                  break;\n                }\n                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n              case 87:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", false);\n              case 89:\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                routeMatch = false;\n                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                  _context2.next = 107;\n                  break;\n                }\n                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context2.next = 106;\n                  break;\n                }\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param];\n                });\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context2.next = 104;\n                  break;\n                }\n                if (process.env.NODE_ENV !== 'production') {\n                  console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                }\n                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n              case 104:\n                _context2.next = 107;\n                break;\n              case 106:\n                if (shouldInterpolate) {\n                  as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omit(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n              case 107:\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeStart', as, routeProps);\n                }\n                _context2.prev = 108;\n                _context2.next = 111;\n                return _this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch\n                });\n              case 111:\n                routeInfo = _context2.sent;\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n                  cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n                  if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n                    if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                      rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                      localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);\n                      nextState.locale = localeResult.detectedLocale || nextState.locale;\n                      rewriteAs = localeResult.pathname;\n                    }\n                    _routeRegex2 = (0, _routeRegex).getRouteRegex(pathname);\n                    curRouteMatch = (0, _routeMatcher).getRouteMatcher(_routeRegex2)(rewriteAs);\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if (!('type' in routeInfo)) {\n                  _context2.next = 120;\n                  break;\n                }\n                if (!(routeInfo.type === 'redirect-internal')) {\n                  _context2.next = 118;\n                  break;\n                }\n                return _context2.abrupt(\"return\", _this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n              case 118:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n              case 120:\n                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP;\n                component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script).handleClientScriptLoad(script.props);\n                  });\n                }\n                // handle redirect on client-transition\n                if (!((__N_SSG || __N_SSP) && props)) {\n                  _context2.next = 150;\n                  break;\n                }\n                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                  _context2.next = 134;\n                  break;\n                }\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context2.next = 132;\n                  break;\n                }\n                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context2.abrupt(\"return\", _this.change(method, newUrl, newAs, options));\n              case 132:\n                handleHardNavigation({\n                  url: destination,\n                  router: _this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n              case 134:\n                nextState.isPreview = !!props.__N_PREVIEW;\n                // handle SSG data 404\n                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context2.next = 150;\n                  break;\n                }\n                _context2.prev = 136;\n                _context2.next = 139;\n                return _this.fetchComponent('/404');\n              case 139:\n                notFoundRoute = '/404';\n                _context2.next = 145;\n                break;\n              case 142:\n                _context2.prev = 142;\n                _context2.t2 = _context2[\"catch\"](136);\n                notFoundRoute = '/_error';\n              case 145:\n                _context2.next = 147;\n                return _this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview\n                });\n              case 147:\n                routeInfo = _context2.sent;\n                if (!('type' in routeInfo)) {\n                  _context2.next = 150;\n                  break;\n                }\n                throw new Error(\"Unexpected middleware effect on /404\");\n              case 150:\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n                _this.changeState(method, url, as, options);\n                if (isQueryUpdating && pathname === '/_error' && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  props.pageProps.statusCode = 500;\n                }\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null; // the new state that the router gonna set\n                upcomingRouterState = _extends({}, nextState, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                });\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (canSkipUpdating) {\n                  _context2.next = 169;\n                  break;\n                }\n                _context2.next = 162;\n                return _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch(function (e) {\n                  if (e.cancelled) error = error || e;else throw e;\n                });\n              case 162:\n                if (!error) {\n                  _context2.next = 165;\n                  break;\n                }\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                }\n                throw error;\n              case 165:\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  if (nextState.locale) {\n                    document.documentElement.lang = nextState.locale;\n                  }\n                }\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeComplete', as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                  _this.scrollToHash(as);\n                }\n              case 169:\n                return _context2.abrupt(\"return\", true);\n              case 172:\n                _context2.prev = 172;\n                _context2.t3 = _context2[\"catch\"](108);\n                if (!((0, _isError).default(_context2.t3) && _context2.t3.cancelled)) {\n                  _context2.next = 176;\n                  break;\n                }\n                return _context2.abrupt(\"return\", false);\n              case 176:\n                throw _context2.t3;\n              case 177:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[38, 43], [51, 60], [108, 172], [136, 142]]);\n      }))();\n    }\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof window.history === 'undefined') {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n        if (typeof window.history[method] === 'undefined') {\n          console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n          return;\n        }\n      }\n      if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== 'pushState' ? this._key : createKey()\n        },\n        // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        '', as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n      var _this = this;\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var props, _yield$_this$fetchCom, Component, styleSheets, routeInfo;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                console.error(err);\n                if (!err.cancelled) {\n                  _context3.next = 3;\n                  break;\n                }\n                throw err;\n              case 3:\n                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                  _context3.next = 7;\n                  break;\n                }\n                Router.events.emit('routeChangeError', err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n              case 7:\n                _context3.prev = 7;\n                _context3.next = 10;\n                return _this.fetchComponent('/_error');\n              case 10:\n                _yield$_this$fetchCom = _context3.sent;\n                Component = _yield$_this$fetchCom.page;\n                styleSheets = _yield$_this$fetchCom.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n                if (routeInfo.props) {\n                  _context3.next = 25;\n                  break;\n                }\n                _context3.prev = 15;\n                _context3.next = 18;\n                return _this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n              case 18:\n                routeInfo.props = _context3.sent;\n                _context3.next = 25;\n                break;\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](15);\n                console.error('Error in error page `getInitialProps`: ', _context3.t0);\n                routeInfo.props = {};\n              case 25:\n                return _context3.abrupt(\"return\", routeInfo);\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](7);\n                return _context3.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).default(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + ''), pathname, query, as, routeProps, true));\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[7, 28], [15, 21]]);\n      }))();\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(_ref7) {\n      var requestedRoute = _ref7.route,\n        pathname = _ref7.pathname,\n        query = _ref7.query,\n        as = _ref7.as,\n        resolvedAs = _ref7.resolvedAs,\n        routeProps = _ref7.routeProps,\n        locale = _ref7.locale,\n        hasMiddleware = _ref7.hasMiddleware,\n        isPreview = _ref7.isPreview,\n        unstable_skipClientCache = _ref7.unstable_skipClientCache;\n      var _this = this;\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var route, ref, ref4, ref5, handleCancelled, existingInfo, cachedRouteInfo, fetchNextDataParams, data, routeInfo, _require, isValidElementType, shouldFetchData, _yield$_this$_getData, props, cacheKey;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */route = requestedRoute;\n                _context5.prev = 1;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                existingInfo = _this.components[route];\n                if (!(routeProps.shallow && existingInfo && _this.route === route)) {\n                  _context5.next = 6;\n                  break;\n                }\n                return _context5.abrupt(\"return\", existingInfo);\n              case 6:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n                cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n                fetchNextDataParams = {\n                  dataHref: _this.pageLoader.getDataHref({\n                    href: (0, _formatUrl).formatWithValidation({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: _this.isSsr,\n                  parseJSON: true,\n                  inflightCache: _this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache\n                };\n                _context5.next = 11;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: resolvedAs,\n                  locale: locale,\n                  router: _this\n                });\n              case 11:\n                data = _context5.sent;\n                handleCancelled();\n                if (!((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === 'redirect-external')) {\n                  _context5.next = 15;\n                  break;\n                }\n                return _context5.abrupt(\"return\", data.effect);\n              case 15:\n                if (!((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === 'rewrite')) {\n                  _context5.next = 23;\n                  break;\n                }\n                route = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                pathname = data.effect.resolvedHref;\n                query = _extends({}, query, data.effect.parsedAs.query);\n                resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                // Check again the cache with the new destination.\n                existingInfo = _this.components[route];\n                if (!(routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware)) {\n                  _context5.next = 23;\n                  break;\n                }\n                return _context5.abrupt(\"return\", _extends({}, existingInfo, {\n                  route: route\n                }));\n              case 23:\n                if (!(route === '/api' || route.startsWith('/api/'))) {\n                  _context5.next = 26;\n                  break;\n                }\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context5.abrupt(\"return\", new Promise(function () {}));\n              case 26:\n                _context5.t0 = cachedRouteInfo;\n                if (_context5.t0) {\n                  _context5.next = 31;\n                  break;\n                }\n                _context5.next = 30;\n                return _this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n              case 30:\n                _context5.t0 = _context5.sent;\n              case 31:\n                routeInfo = _context5.t0;\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context5.next = 36;\n                  break;\n                }\n                _require = require('next/dist/compiled/react-is'), isValidElementType = _require.isValidElementType;\n                if (isValidElementType(routeInfo.Component)) {\n                  _context5.next = 36;\n                  break;\n                }\n                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n              case 36:\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                _context5.next = 39;\n                return _this._getData(_async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  var _ref8, json, _cacheKey;\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context4.next = 12;\n                            break;\n                          }\n                          if (!(data == null ? void 0 : data.json)) {\n                            _context4.next = 5;\n                            break;\n                          }\n                          _context4.t0 = data;\n                          _context4.next = 8;\n                          break;\n                        case 5:\n                          _context4.next = 7;\n                          return fetchNextData({\n                            dataHref: _this.pageLoader.getDataHref({\n                              href: (0, _formatUrl).formatWithValidation({\n                                pathname: pathname,\n                                query: query\n                              }),\n                              asPath: resolvedAs,\n                              locale: locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n                        case 7:\n                          _context4.t0 = _context4.sent;\n                        case 8:\n                          _ref8 = _context4.t0;\n                          json = _ref8.json;\n                          _cacheKey = _ref8.cacheKey;\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: _cacheKey,\n                            props: json || {}\n                          });\n                        case 12:\n                          _context4.t1 = {};\n                          _context4.next = 15;\n                          return _this.getInitialProps(routeInfo.Component,\n                          // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                          });\n                        case 15:\n                          _context4.t2 = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            headers: _context4.t1,\n                            cacheKey: '',\n                            props: _context4.t2\n                          });\n                        case 17:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n              case 39:\n                _yield$_this$_getData = _context5.sent;\n                props = _yield$_this$_getData.props;\n                cacheKey = _yield$_this$_getData.cacheKey;\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                  delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development') {\n                  fetchNextData(Object.assign({}, fetchNextDataParams, {\n                    isBackground: true,\n                    persistCache: false,\n                    inflightCache: backgroundCache\n                  })).catch(function () {});\n                }\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return _context5.abrupt(\"return\", routeInfo);\n              case 53:\n                _context5.prev = 53;\n                _context5.t1 = _context5[\"catch\"](1);\n                return _context5.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).getProperError(_context5.t1), pathname, query, as, routeProps));\n              case 56:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[1, 53]]);\n      }))();\n    }\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n      var _this$asPath$split = this.asPath.split('#'),\n        _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n        oldUrlNoHash = _this$asPath$split2[0],\n        oldHash = _this$asPath$split2[1];\n      var _as$split = as.split('#'),\n        _as$split2 = _slicedToArray(_as$split, 2),\n        newUrlNoHash = _as$split2[0],\n        newHash = _as$split2[1];\n      // Makes sure we scroll to the provided hash if the url/hash are the same\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      }\n      // If the urls are change, there's more than a hash change\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      }\n      // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split('#'),\n        _as$split4 = _slicedToArray(_as$split3, 2),\n        _as$split4$ = _as$split4[1],\n        hash = _as$split4$ === void 0 ? '' : _as$split4$;\n      // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n      if (hash === '' || hash === 'top') {\n        handleSmoothScroll(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      }\n      // Decode hash to make non-latin anchor works.\n      var rawHash = decodeURIComponent(hash);\n      // First we check if the element by id is found\n      var idEl = document.getElementById(rawHash);\n      if (idEl) {\n        handleSmoothScroll(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      }\n      // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n      var nameEl = document.getElementsByName(rawHash)[0];\n      if (nameEl) {\n        handleSmoothScroll(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(url) {\n      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _this = this;\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, locale, rewrites, _yield$getClientBuild, rewritesResult, route;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof window !== 'undefined' && (0, _isBot).isBot(window.navigator.userAgent))) {\n                  _context6.next = 2;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 2:\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query;\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                  if (options.locale === false) {\n                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                    parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                    localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                    parsedAs.pathname = localePathResult.pathname;\n                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;\n                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n                  }\n                }\n                _context6.next = 7;\n                return _this.pageLoader.getPageList();\n              case 7:\n                pages = _context6.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n                if (!(process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/'))) {\n                  _context6.next = 20;\n                  break;\n                }\n                _context6.next = 13;\n                return (0, _routeLoader).getClientBuildManifest();\n              case 13:\n                _yield$getClientBuild = _context6.sent;\n                rewrites = _yield$getClientBuild.__rewrites;\n                rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n                if (!rewritesResult.externalDest) {\n                  _context6.next = 18;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 18:\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n                  url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n              case 20:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                  url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context6.next = 24;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 24:\n                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                _context6.next = 27;\n                return Promise.all([_this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: _this.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !_this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                  }).then(function () {\n                    return false;\n                  }) : false;\n                }), _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n              case 27:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    }\n  }, {\n    key: \"fetchComponent\",\n    value: function fetchComponent(route) {\n      var _this = this;\n      return _async_to_generator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                _context7.prev = 1;\n                _context7.next = 4;\n                return _this.pageLoader.loadPage(route);\n              case 4:\n                componentResult = _context7.sent;\n                handleCancelled();\n                return _context7.abrupt(\"return\", componentResult);\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](1);\n                handleCancelled();\n                throw _context7.t0;\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[1, 9]]);\n      }))();\n    }\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this3 = this;\n      var cancelled = false;\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this3.clc) {\n          _this3.clc = null;\n        }\n        if (cancelled) {\n          var err = new Error('Loading initial props cancelled');\n          err.cancelled = true;\n          throw err;\n        }\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (_ref9) {\n        var text = _ref9.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components['/_app'].Component;\n      var AppTree = this._wrapApp(App);\n      ctx.AppTree = AppTree;\n      return (0, _utils).loadGetInitialProps(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n  return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports.default = Router;","map":{"version":3,"sources":["../../../../shared/lib/router/router.ts"],"names":["buildCancellationError","Object","assign","Error","cancelled","matchesMiddleware","options","matchers","Promise","resolve","router","pageLoader","getMiddleware","pathname","asPathname","parsePath","asPath","cleanedAs","hasBasePath","removeBasePath","asWithBasePathAndLocale","addBasePath","addLocale","locale","some","m","RegExp","regexp","test","stripOrigin","url","origin","getLocationOrigin","startsWith","substring","length","omit","object","keys","omitted","forEach","key","includes","isLocalURL","isAbsoluteUrl","locationOrigin","resolved","URL","_","interpolateAs","route","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","every","param","value","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result","resolveHref","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","urlParts","split","console","error","normalizedUrl","normalizeRepeatedSlashes","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","searchParamsToUrlQuery","hash","resolvedHref","prepareUrlAs","as","resolvedAs","hrefHadOrigin","asHadOrigin","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removeTrailingSlash","denormalizePagePath","page","re","getMiddlewareData","source","response","nextConfig","basePath","i18n","locales","trailingSlash","Boolean","process","env","__NEXT_TRAILING_SLASH","rewriteHeader","headers","get","rewriteTarget","matchedPath","parsedRewriteTarget","parseRelativeUrl","pathnameInfo","getNextPathnameInfo","parseData","fsPathname","all","getPageList","getClientBuildManifest","then","__rewrites","rewrites","normalizeLocalePath","parsedSource","__NEXT_HAS_REWRITES","resolveRewrites","path","matchedPage","parsedAs","resolvedPathname","matches","type","src","formatNextPathnameInfo","defaultLocale","buildId","destination","redirectTarget","newAs","newUrl","withMiddlewareEffects","fetchData","data","dataHref","effect","cacheKey","json","text","catch","_err","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","fetch","credentials","method","ok","status","backgroundCache","handleSmoothScroll","fn","htmlElement","document","documentElement","existing","style","scrollBehavior","tryToParseAsJSON","JSON","parse","fetchNextData","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","location","getData","purpose","notFound","markAssetError","NODE_ENV","err","undefined","createKey","Math","random","toString","handleHardNavigation","getCancelledHandler","cancel","clc","handleCancelled","Router","sdc","isFirstPopStateEvent","_key","events","mitt","constructor","initialProps","App","wrapApp","Component","subscription","isFallback","domainLocales","isPreview","components","initial","props","__N_SSG","__N_SSP","styleSheets","autoExportDynamic","self","__NEXT_DATA__","autoExport","__NEXT_ROUTER_BASEPATH","sub","_wrapApp","isSsr","isLocaleDomain","isReady","gssp","gip","appGip","gsp","search","__NEXT_I18N_SUPPORT","detectDomainLocale","hostname","state","_initialMatchesMiddlewarePromise","getURL","_shouldResolveHref","changeState","addEventListener","onPopState","scrollRestoration","e","__NA","reload","__N","forcedScroll","stringify","x","pageXOffset","y","pageYOffset","getItem","_bps","change","shallow","_shallow","_h","back","push","isQueryUpdating","shouldResolveHref","nextState","readyStateChange","prevLocale","localePathResult","detectedLocale","didNavigate","detectedDomain","domain","asNoBasePath","http","ST","performance","mark","scroll","routeProps","_inFlightRoute","emit","removeLocale","localeChange","onlyAHashChange","scrollToHash","set","isError","parsed","urlIsNew","isMiddlewareMatch","rewritesResult","p","externalDest","routeMatch","routeRegex","shouldInterpolate","missingParams","filter","warn","routeInfo","getRouteInfo","cleanedParsedPathname","prefixedAs","rewriteAs","localeResult","curRouteMatch","component","unstable_scriptLoader","scripts","concat","script","handleClientScriptLoad","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","fetchComponent","notFoundRoute","statusCode","isValidShallowRoute","shouldScroll","resetScroll","upcomingRouterState","upcomingScrollState","canSkipUpdating","compareRouterStates","lang","hashRegex","handleRouteInfoError","loadErrorFail","isAssetError","getInitialProps","routeInfoErr","requestedRoute","existingInfo","cachedRouteInfo","fetchNextDataParams","getDataHref","skipInterpolation","res","mod","isValidElementType","require","shouldFetchData","_getData","_cacheKey","getProperError","beforePopState","cb","oldUrlNoHash","oldHash","newUrlNoHash","newHash","scrollTo","rawHash","decodeURIComponent","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","prefetch","isBot","navigator","userAgent","_isSsg","isSsg","priority","__NEXT_OPTIMISTIC_CLIENT_CACHE","componentResult","loadPage","_getFlightData","ctx","AppTree","loadGetInitialProps"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchesMiddleware = matchesMiddleware;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports.default = void 0;\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _removeTrailingSlash = require(\"./utils/remove-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _script = require(\"../../../client/script\");\nvar _isError = _interop_require_wildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interop_require_default(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interop_require_default(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _formatUrl = require(\"./utils/format-url\");\nvar _detectDomainLocale = require(\"../../../client/detect-domain-locale\");\nvar _parsePath = require(\"./utils/parse-path\");\nvar _addLocale = require(\"../../../client/add-locale\");\nvar _removeLocale = require(\"../../../client/remove-locale\");\nvar _removeBasePath = require(\"../../../client/remove-base-path\");\nvar _addBasePath = require(\"../../../client/add-base-path\");\nvar _hasBasePath = require(\"../../../client/has-base-path\");\nvar _getNextPathnameInfo = require(\"./utils/get-next-pathname-info\");\nvar _formatNextPathnameInfo = require(\"./utils/format-next-pathname-info\");\nvar _compareStates = require(\"./utils/compare-states\");\nvar _isBot = require(\"./utils/is-bot\");\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function*(options) {\n        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());\n        if (!matchers) return false;\n        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);\n        // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n        // Check only path match on client. Matching \"has\" should be done on server\n        // where we can access more info such as headers, HttpOnly cookie, etc.\n        return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils).isAbsoluteUrl(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omit(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get('x-matched-path');\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/')) {\n            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(), \n            ]).then(([pages, { __rewrites: rewrites  }])=>{\n                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (process.env.__NEXT_HAS_REWRITES) {\n                    const result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsePath).parsePath(source);\n        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        }));\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsePath).parsePath(redirectTarget);\n            const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n                nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            }));\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return matchesMiddleware(options).then((matches)=>{\n        if (matches && options.fetchData) {\n            return options.fetchData().then((data)=>getMiddlewareData(data.dataHref, data.response, options).then((effect)=>({\n                        dataHref: data.dataHref,\n                        cacheKey: data.cacheKey,\n                        json: data.json,\n                        response: data.response,\n                        text: data.text,\n                        effect\n                    }))).catch((_err)=>{\n                /**\n           * TODO: Revisit this in the future.\n           * For now we will not consider middleware data errors to be fatal.\n           * maybe we should revisit in the future.\n           */ return null;\n            });\n        }\n        return null;\n    });\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nconst backgroundCache = {};\nfunction handleSmoothScroll(fn) {\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData({ dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  }) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    var ref1;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: isPrefetch ? {\n                purpose: 'prefetch'\n            } : {},\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (!hasMiddleware && response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(`Failed to load static props`);\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            delete inflightCache[cacheKey];\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url , router  }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route , router  })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error(`Abort fetching component for route: \"${route}\"`);\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch (e) {}\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    change(method, url, as, options, forcedScroll) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (!isLocalURL(url)) {\n                handleHardNavigation({\n                    url,\n                    router: _this\n                });\n                return false;\n            }\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n            const isQueryUpdating = options._h;\n            const shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n            const nextState = _extends({}, _this.state);\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            // or a navigation has occurred\n            const readyStateChange = _this.isReady !== true;\n            _this.isReady = true;\n            const isSsr = _this.isSsr;\n            if (!isQueryUpdating) {\n                _this.isSsr = false;\n            }\n            // if a route transition is already in progress before\n            // the query updating is triggered ignore query updating\n            if (isQueryUpdating && _this.clc) {\n                return false;\n            }\n            const prevLocale = nextState.locale;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n                if (typeof options.locale === 'undefined') {\n                    options.locale = nextState.locale;\n                }\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                if (localePathResult.detectedLocale) {\n                    nextState.locale = localePathResult.detectedLocale;\n                    parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);\n                    as = (0, _formatUrl).formatWithValidation(parsedAs);\n                    url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);\n                }\n                let didNavigate = false;\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    var ref;\n                    // if the locale isn't configured hard navigate to show 404 page\n                    if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {\n                        parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);\n                        handleHardNavigation({\n                            url: (0, _formatUrl).formatWithValidation(parsedAs),\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale);\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    // if we are navigating to a domain locale ensure we redirect to the\n                    // correct domain\n                    if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                        const asNoBasePath = (0, _removeBasePath).removeBasePath(as);\n                        handleHardNavigation({\n                            url: `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${(0, _addBasePath).addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`,\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                if (didNavigate) {\n                    return new Promise(()=>{});\n                }\n            }\n            // marking route changes as a navigation start entry\n            if (_utils.ST) {\n                performance.mark('routeChange');\n            }\n            const { shallow =false , scroll =true  } = options;\n            const routeProps = {\n                shallow\n            };\n            if (_this._inFlightRoute && _this.clc) {\n                if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                }\n                _this.clc();\n                _this.clc = null;\n            }\n            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n            _this._inFlightRoute = as;\n            const localeChange = prevLocale !== nextState.locale;\n            // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                    scroll: false\n                }));\n                if (scroll) {\n                    _this.scrollToHash(cleanedAs);\n                }\n                try {\n                    yield _this.set(nextState, _this.components[nextState.route], null);\n                } catch (err) {\n                    if ((0, _isError).default(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return true;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n            let pages, rewrites;\n            try {\n                [pages, { __rewrites: rewrites  }] = yield Promise.all([\n                    _this.pageLoader.getPageList(),\n                    (0, _routeLoader).getClientBuildManifest(),\n                    _this.pageLoader.getMiddleware(), \n                ]);\n            } catch (err) {\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                method = 'replaceState';\n            }\n            // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n            let resolvedAs = as;\n            // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n            // we don't attempt resolve asPath when we need to execute\n            // middleware as the resolving will occur server-side\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: _this\n            });\n            if (options.shallow && isMiddlewareMatch) {\n                pathname = _this.pathname;\n            }\n            if (shouldResolveHref && pathname !== '/_error') {\n                options._shouldResolveHref = true;\n                if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                    const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                    if (rewritesResult.externalDest) {\n                        handleHardNavigation({\n                            url: as,\n                            router: _this\n                        });\n                        return true;\n                    }\n                    if (!isMiddlewareMatch) {\n                        resolvedAs = rewritesResult.asPath;\n                    }\n                    if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                        // if this directly matches a page we need to update the href to\n                        // allow the correct page chunk to be loaded\n                        pathname = rewritesResult.resolvedHref;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                } else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                    if (parsed.pathname !== pathname) {\n                        pathname = parsed.pathname;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                }\n            }\n            if (!isLocalURL(as)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n                }\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            let routeMatch = false;\n            if ((0, _isDynamic).isDynamicRoute(route)) {\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                const asPathname = parsedAs.pathname;\n                const routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                const shouldInterpolate = route === asPathname;\n                const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param]);\n                    if (missingParams.length > 0 && !isMiddlewareMatch) {\n                        if (process.env.NODE_ENV !== 'production') {\n                            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                        }\n                        throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                    }\n                } else if (shouldInterpolate) {\n                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                        pathname: interpolatedAs.result,\n                        query: omit(query, interpolatedAs.params)\n                    }));\n                } else {\n                    // Merge params into `query`, overwriting any specified in search\n                    Object.assign(query, routeMatch);\n                }\n            }\n            if (!isQueryUpdating) {\n                Router.events.emit('routeChangeStart', as, routeProps);\n            }\n            try {\n                var ref2, ref3;\n                let routeInfo = yield _this.getRouteInfo({\n                    route,\n                    pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps,\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    hasMiddleware: isMiddlewareMatch\n                });\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                    pathname = routeInfo.route || route;\n                    route = pathname;\n                    if (!routeProps.shallow) {\n                        query = Object.assign({}, routeInfo.query || {}, query);\n                    }\n                    const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                        Object.keys(routeMatch).forEach((key)=>{\n                            if (routeMatch && query[key] === routeMatch[key]) {\n                                delete query[key];\n                            }\n                        });\n                    }\n                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                        let rewriteAs = prefixedAs;\n                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                        }\n                        if (process.env.__NEXT_I18N_SUPPORT) {\n                            const localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);\n                            nextState.locale = localeResult.detectedLocale || nextState.locale;\n                            rewriteAs = localeResult.pathname;\n                        }\n                        const routeRegex = (0, _routeRegex).getRouteRegex(pathname);\n                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(rewriteAs);\n                        if (curRouteMatch) {\n                            Object.assign(query, curRouteMatch);\n                        }\n                    }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if ('type' in routeInfo) {\n                    if (routeInfo.type === 'redirect-internal') {\n                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                    } else {\n                        handleHardNavigation({\n                            url: routeInfo.destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                }\n                let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n                const component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                    const scripts = [].concat(component.unstable_scriptLoader());\n                    scripts.forEach((script)=>{\n                        (0, _script).handleClientScriptLoad(script.props);\n                    });\n                }\n                // handle redirect on client-transition\n                if ((__N_SSG || __N_SSP) && props) {\n                    if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                        // Use the destination from redirect without adding locale\n                        options.locale = false;\n                        const destination = props.pageProps.__N_REDIRECT;\n                        // check if destination is internal (resolves to a page) and attempt\n                        // client-navigation if it is falling back to hard navigation if\n                        // it's not\n                        if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);\n                            return _this.change(method, newUrl, newAs, options);\n                        }\n                        handleHardNavigation({\n                            url: destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                    nextState.isPreview = !!props.__N_PREVIEW;\n                    // handle SSG data 404\n                    if (props.notFound === SSG_DATA_NOT_FOUND) {\n                        let notFoundRoute;\n                        try {\n                            yield _this.fetchComponent('/404');\n                            notFoundRoute = '/404';\n                        } catch (_) {\n                            notFoundRoute = '/_error';\n                        }\n                        routeInfo = yield _this.getRouteInfo({\n                            route: notFoundRoute,\n                            pathname: notFoundRoute,\n                            query,\n                            as,\n                            resolvedAs,\n                            routeProps: {\n                                shallow: false\n                            },\n                            locale: nextState.locale,\n                            isPreview: nextState.isPreview\n                        });\n                        if ('type' in routeInfo) {\n                            throw new Error(`Unexpected middleware effect on /404`);\n                        }\n                    }\n                }\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n                _this.changeState(method, url, as, options);\n                if (isQueryUpdating && pathname === '/_error' && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    props.pageProps.statusCode = 500;\n                }\n                var _route;\n                // shallow routing is only allowed for same page URL changes.\n                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                var _scroll;\n                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                const resetScroll = shouldScroll ? {\n                    x: 0,\n                    y: 0\n                } : null;\n                // the new state that the router gonna set\n                const upcomingRouterState = _extends({}, nextState, {\n                    route,\n                    pathname,\n                    query,\n                    asPath: cleanedAs,\n                    isFallback: false\n                });\n                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                const canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (!canSkipUpdating) {\n                    yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch((e)=>{\n                        if (e.cancelled) error = error || e;\n                        else throw e;\n                    });\n                    if (error) {\n                        if (!isQueryUpdating) {\n                            Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                        }\n                        throw error;\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                        if (nextState.locale) {\n                            document.documentElement.lang = nextState.locale;\n                        }\n                    }\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeComplete', as, routeProps);\n                    }\n                    // A hash mark # is the optional last part of a URL\n                    const hashRegex = /#.+$/;\n                    if (shouldScroll && hashRegex.test(as)) {\n                        _this.scrollToHash(as);\n                    }\n                }\n                return true;\n            } catch (err1) {\n                if ((0, _isError).default(err1) && err1.cancelled) {\n                    return false;\n                }\n                throw err1;\n            }\n        })();\n    }\n    changeState(method, url, as, options = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            console.error(err);\n            if (err.cancelled) {\n                // bubble up cancellation errors\n                throw err;\n            }\n            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                Router.events.emit('routeChangeError', err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n            }\n            try {\n                let props;\n                const { page: Component , styleSheets  } = yield _this.fetchComponent('/_error');\n                const routeInfo = {\n                    props,\n                    Component,\n                    styleSheets,\n                    err,\n                    error: err\n                };\n                if (!routeInfo.props) {\n                    try {\n                        routeInfo.props = yield _this.getInitialProps(Component, {\n                            err,\n                            pathname,\n                            query\n                        });\n                    } catch (gipErr) {\n                        console.error('Error in error page `getInitialProps`: ', gipErr);\n                        routeInfo.props = {};\n                    }\n                }\n                return routeInfo;\n            } catch (routeInfoErr) {\n                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n            }\n        })();\n    }\n    getRouteInfo({ route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache  }) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n            try {\n                var ref, ref4, ref5;\n                const handleCancelled = getCancelledHandler({\n                    route,\n                    router: _this\n                });\n                let existingInfo = _this.components[route];\n                if (routeProps.shallow && existingInfo && _this.route === route) {\n                    return existingInfo;\n                }\n                if (hasMiddleware) {\n                    existingInfo = undefined;\n                }\n                let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n                const fetchNextDataParams = {\n                    dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                            pathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this.isSsr,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !isPreview,\n                    isPrefetch: false,\n                    unstable_skipClientCache\n                };\n                const data = yield withMiddlewareEffects({\n                    fetchData: ()=>fetchNextData(fetchNextDataParams),\n                    asPath: resolvedAs,\n                    locale: locale,\n                    router: _this\n                });\n                handleCancelled();\n                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === 'redirect-external') {\n                    return data.effect;\n                }\n                if ((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === 'rewrite') {\n                    route = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                    pathname = data.effect.resolvedHref;\n                    query = _extends({}, query, data.effect.parsedAs.query);\n                    resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = _this.components[route];\n                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return _extends({}, existingInfo, {\n                            route\n                        });\n                    }\n                }\n                if (route === '/api' || route.startsWith('/api/')) {\n                    handleHardNavigation({\n                        url: as,\n                        router: _this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({\n                        Component: res.page,\n                        styleSheets: res.styleSheets,\n                        __N_SSG: res.mod.__N_SSG,\n                        __N_SSP: res.mod.__N_SSP\n                    })));\n                if (process.env.NODE_ENV !== 'production') {\n                    const { isValidElementType  } = require('next/dist/compiled/react-is');\n                    if (!isValidElementType(routeInfo.Component)) {\n                        throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                    }\n                }\n                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                const { props , cacheKey  } = yield _this._getData(_async_to_generator(function*() {\n                    if (shouldFetchData) {\n                        const { json , cacheKey: _cacheKey  } = (data == null ? void 0 : data.json) ? data : yield fetchNextData({\n                            dataHref: _this.pageLoader.getDataHref({\n                                href: (0, _formatUrl).formatWithValidation({\n                                    pathname,\n                                    query\n                                }),\n                                asPath: resolvedAs,\n                                locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache\n                        });\n                        return {\n                            cacheKey: _cacheKey,\n                            props: json || {}\n                        };\n                    }\n                    return {\n                        headers: {},\n                        cacheKey: '',\n                        props: yield _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                        {\n                            pathname,\n                            query,\n                            asPath: as,\n                            locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                        })\n                    };\n                }));\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                    delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development') {\n                    fetchNextData(Object.assign({}, fetchNextDataParams, {\n                        isBackground: true,\n                        persistCache: false,\n                        inflightCache: backgroundCache\n                    })).catch(()=>{});\n                }\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return routeInfo;\n            } catch (err) {\n                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n            }\n        })();\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            handleSmoothScroll(()=>window.scrollTo(0, 0));\n            return;\n        }\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash);\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash);\n        if (idEl) {\n            handleSmoothScroll(()=>idEl.scrollIntoView());\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0];\n        if (nameEl) {\n            handleSmoothScroll(()=>nameEl.scrollIntoView());\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ prefetch(url, asPath = url, options = {}) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (typeof window !== 'undefined' && (0, _isBot).isBot(window.navigator.userAgent)) {\n                // No prefetches for bots that render the link since they are typically navigating\n                // links via the equivalent of a hard navigation and hence never utilize these\n                // prefetches.\n                return;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (options.locale === false) {\n                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                    const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                    parsedAs.pathname = localePathResult.pathname;\n                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;\n                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n                }\n            }\n            const pages = yield _this.pageLoader.getPageList();\n            let resolvedAs = asPath;\n            const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n            if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n                let rewrites;\n                ({ __rewrites: rewrites  } = yield (0, _routeLoader).getClientBuildManifest());\n                const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                if (rewritesResult.externalDest) {\n                    return;\n                }\n                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            }\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n            // Prefetch is not supported in development mode because it would trigger on-demand-entries\n            if (process.env.NODE_ENV !== 'production') {\n                return;\n            }\n            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            yield Promise.all([\n                _this.pageLoader._isSsg(route).then((isSsg)=>{\n                    return isSsg ? fetchNextData({\n                        dataHref: _this.pageLoader.getDataHref({\n                            href: url,\n                            asPath: resolvedAs,\n                            locale: locale\n                        }),\n                        isServerRender: false,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true,\n                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                    }).then(()=>false) : false;\n                }),\n                _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n            ]);\n        })();\n    }\n    fetchComponent(route) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: _this\n            });\n            try {\n                const componentResult = yield _this.pageLoader.loadPage(route);\n                handleCancelled();\n                return componentResult;\n            } catch (err) {\n                handleCancelled();\n                throw err;\n            }\n        })();\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then(({ text  })=>({\n                data: text\n            }));\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Server Data Cache\n        this.sdc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent  } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , key  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._key !== key) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch (e) {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + key);\n                            forcedScroll = JSON.parse(v);\n                        } catch (e1) {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._key = key;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname === (0, _addBasePath).addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as1 !== pathname1;\n                    this.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n}\nRouter.events = (0, _mitt).default();\nexports.default = Router;\n\n//# sourceMappingURL=router.js.map"]},"metadata":{},"sourceType":"script"}